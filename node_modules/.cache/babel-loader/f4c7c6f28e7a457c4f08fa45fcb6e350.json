{"ast":null,"code":"import React from 'react';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar defaultColumn = {\n  Cell: function Cell(_ref) {\n    var _ref$cell$value = _ref.cell.value,\n        value = _ref$cell$value === void 0 ? '' : _ref$cell$value;\n    return String(value);\n  },\n  show: true,\n  width: 150,\n  minWidth: 0,\n  maxWidth: Number.MAX_SAFE_INTEGER\n}; // SSR has issues with useLayoutEffect still, so use useEffect during SSR\n\nvar safeUseLayoutEffect = typeof window !== 'undefined' && process.env.NODE_ENV === 'production' ? React.useLayoutEffect : React.useEffect; // Find the depth of the columns\n\nfunction findMaxDepth(columns) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return columns.reduce(function (prev, curr) {\n    if (curr.columns) {\n      return Math.max(prev, findMaxDepth(curr.columns, depth + 1));\n    }\n\n    return depth;\n  }, 0);\n}\n\nfunction decorateColumn(column, userDefaultColumn, parent, depth, index) {\n  // Apply the userDefaultColumn\n  column = _objectSpread2({}, defaultColumn, {}, userDefaultColumn, {}, column); // First check for string accessor\n\n  var _column = column,\n      id = _column.id,\n      accessor = _column.accessor,\n      Header = _column.Header;\n\n  if (typeof accessor === 'string') {\n    id = id || accessor;\n    var accessorPath = accessor.split('.');\n\n    accessor = function accessor(row) {\n      return getBy(row, accessorPath);\n    };\n  }\n\n  if (!id && typeof Header === 'string' && Header) {\n    id = Header;\n  }\n\n  if (!id && column.columns) {\n    console.error(column);\n    throw new Error('A column ID (or unique \"Header\" value) is required!');\n  }\n\n  if (!id) {\n    console.error(column);\n    throw new Error('A column ID (or string accessor) is required!');\n  }\n\n  column = _objectSpread2({\n    // Make sure there is a fallback header, just in case\n    Header: function Header() {\n      return React.createElement(React.Fragment, null, \"\\xA0\");\n    }\n  }, column, {\n    // Materialize and override this stuff\n    id: id,\n    accessor: accessor,\n    parent: parent,\n    depth: depth,\n    index: index\n  });\n  return column;\n} // Build the visible columns, headers and flat column list\n\n\nfunction decorateColumnTree(columns, defaultColumn, parent) {\n  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  return columns.map(function (column, columnIndex) {\n    column = decorateColumn(column, defaultColumn, parent, depth, columnIndex);\n\n    if (column.columns) {\n      column.columns = decorateColumnTree(column.columns, defaultColumn, column, depth + 1);\n    }\n\n    return column;\n  });\n} // Build the header groups from the bottom up\n\n\nfunction makeHeaderGroups(flatColumns, defaultColumn) {\n  var headerGroups = []; // Build each header group from the bottom up\n\n  var buildGroup = function buildGroup(columns, depth) {\n    var headerGroup = {\n      headers: []\n    };\n    var parentColumns = []; // Do any of these columns have parents?\n\n    var hasParents = columns.some(function (col) {\n      return col.parent;\n    });\n    columns.forEach(function (column) {\n      // Are we the first column in this group?\n      var isFirst = !parentColumns.length; // What is the latest (last) parent column?\n\n      var latestParentColumn = [].concat(parentColumns).reverse()[0]; // If the column has a parent, add it if necessary\n\n      if (column.parent) {\n        var similarParentColumns = parentColumns.filter(function (d) {\n          return d.originalID === column.parent.id;\n        });\n\n        if (isFirst || latestParentColumn.originalID !== column.parent.id) {\n          parentColumns.push(_objectSpread2({}, column.parent, {\n            originalID: column.parent.id,\n            id: [column.parent.id, similarParentColumns.length].join('_')\n          }));\n        }\n      } else if (hasParents) {\n        // If other columns have parents, we'll need to add a place holder if necessary\n        var originalID = [column.id, 'placeholder'].join('_');\n\n        var _similarParentColumns = parentColumns.filter(function (d) {\n          return d.originalID === originalID;\n        });\n\n        var placeholderColumn = decorateColumn({\n          originalID: originalID,\n          id: [column.id, 'placeholder', _similarParentColumns.length].join('_'),\n          placeholderOf: column\n        }, defaultColumn);\n\n        if (isFirst || latestParentColumn.originalID !== placeholderColumn.originalID) {\n          parentColumns.push(placeholderColumn);\n        }\n      } // Establish the new headers[] relationship on the parent\n\n\n      if (column.parent || hasParents) {\n        latestParentColumn = [].concat(parentColumns).reverse()[0];\n        latestParentColumn.headers = latestParentColumn.headers || [];\n\n        if (!latestParentColumn.headers.includes(column)) {\n          latestParentColumn.headers.push(column);\n        }\n      }\n\n      column.totalHeaderCount = column.headers ? column.headers.reduce(function (sum, header) {\n        return sum + header.totalHeaderCount;\n      }, 0) : 1; // Leaf node columns take up at least one count\n\n      headerGroup.headers.push(column);\n    });\n    headerGroups.push(headerGroup);\n\n    if (parentColumns.length) {\n      buildGroup(parentColumns);\n    }\n  };\n\n  buildGroup(flatColumns);\n  return headerGroups.reverse();\n}\n\nfunction determineHeaderVisibility(instance) {\n  var headers = instance.headers;\n\n  var handleColumn = function handleColumn(column, parentVisible) {\n    column.isVisible = parentVisible ? typeof column.show === 'function' ? column.show(instance) : !!column.show : false;\n    var totalVisibleHeaderCount = 0;\n\n    if (column.headers && column.headers.length) {\n      column.headers.forEach(function (subColumn) {\n        return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);\n      });\n    } else {\n      totalVisibleHeaderCount = column.isVisible ? 1 : 0;\n    }\n\n    column.totalVisibleHeaderCount = totalVisibleHeaderCount;\n    return totalVisibleHeaderCount;\n  };\n\n  var totalVisibleHeaderCount = 0;\n  headers.forEach(function (subHeader) {\n    return totalVisibleHeaderCount += handleColumn(subHeader, true);\n  });\n}\n\nfunction getBy(obj, path, def) {\n  if (!path) {\n    return obj;\n  }\n\n  var pathObj = makePathArray(path);\n  var val;\n\n  try {\n    val = pathObj.reduce(function (cursor, pathPart) {\n      return cursor[pathPart];\n    }, obj);\n  } catch (e) {// continue regardless of error\n  }\n\n  return typeof val !== 'undefined' ? val : def;\n}\n\nfunction defaultOrderByFn(arr, funcs, dirs) {\n  return _toConsumableArray(arr).sort(function (rowA, rowB) {\n    for (var i = 0; i < funcs.length; i += 1) {\n      var sortFn = funcs[i];\n      var desc = dirs[i] === false || dirs[i] === 'desc';\n      var sortInt = sortFn(rowA, rowB);\n\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt;\n      }\n    }\n\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;\n  });\n}\n\nfunction getFirstDefined() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  for (var i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i];\n    }\n  }\n}\n\nfunction defaultGroupByFn(rows, columnID) {\n  return rows.reduce(function (prev, row, i) {\n    // TODO: Might want to implement a key serializer here so\n    // irregular column values can still be grouped if needed?\n    var resKey = \"\".concat(row.values[columnID]);\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];\n    prev[resKey].push(row);\n    return prev;\n  }, {});\n}\n\nfunction getElementDimensions(element) {\n  var rect = element.getBoundingClientRect();\n  var style = window.getComputedStyle(element);\n  var margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight)\n  };\n  var padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight)\n  };\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(rect.width + margins.left + margins.right + padding.left + padding.right),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth\n  };\n}\n\nfunction flexRender(Comp, props) {\n  return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;\n}\n\nfunction isClassComponent(component) {\n  return typeof component === 'function' && !!function () {\n    var proto = Object.getPrototypeOf(component);\n    return proto.prototype && proto.prototype.isReactComponent;\n  }();\n}\n\nfunction isFunctionComponent(component) {\n  return typeof component === 'function';\n}\n\nfunction isReactComponent(component) {\n  return isClassComponent(component) || isFunctionComponent(component);\n}\n\nvar mergeProps = function mergeProps() {\n  var props = {};\n\n  for (var _len2 = arguments.length, groups = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    groups[_key2] = arguments[_key2];\n  }\n\n  groups.forEach(function () {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$style = _ref2.style,\n        style = _ref2$style === void 0 ? {} : _ref2$style,\n        className = _ref2.className,\n        rest = _objectWithoutProperties(_ref2, [\"style\", \"className\"]);\n\n    props = _objectSpread2({}, props, {}, rest, {\n      style: _objectSpread2({}, props.style || {}, {}, style),\n      className: [props.className, className].filter(Boolean).join(' ')\n    });\n  });\n\n  if (props.className === '') {\n    delete props.className;\n  }\n\n  return props;\n};\n\nvar applyHooks = function applyHooks(hooks, initial) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n    args[_key3 - 2] = arguments[_key3];\n  }\n\n  return hooks.reduce(function (prev, next) {\n    var nextValue = next.apply(void 0, [prev].concat(args));\n\n    if (typeof nextValue === 'undefined') {\n      throw new Error('React Table: A hook just returned undefined! This is not allowed.');\n    }\n\n    return nextValue;\n  }, initial);\n};\n\nvar applyPropHooks = function applyPropHooks(hooks) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  return hooks.reduce(function (prev, next) {\n    return mergeProps(prev, next.apply(void 0, args));\n  }, {});\n};\n\nvar warnUnknownProps = function warnUnknownProps(props) {\n  if (Object.keys(props).length) {\n    throw new Error(\"Unknown options passed to useReactTable:\\n\\n\".concat(JSON.stringify(props, null, 2)));\n  }\n};\n\nfunction sum(arr) {\n  return arr.reduce(function (prev, curr) {\n    return prev + curr;\n  }, 0);\n}\n\nfunction isFunction(a) {\n  if (typeof a === 'function') {\n    return a;\n  }\n}\n\nfunction flattenBy(columns, childKey) {\n  var flatColumns = [];\n\n  var recurse = function recurse(columns) {\n    columns.forEach(function (d) {\n      if (!d[childKey]) {\n        flatColumns.push(d);\n      } else {\n        recurse(d[childKey]);\n      }\n    });\n  };\n\n  recurse(columns);\n  return flatColumns;\n}\n\nfunction ensurePluginOrder(plugins, befores, pluginName, afters) {\n  var pluginIndex = plugins.findIndex(function (plugin) {\n    return plugin.pluginName === pluginName;\n  });\n\n  if (pluginIndex === -1) {\n    throw new Error(\"The plugin \".concat(pluginName, \" was not found in the plugin list!\\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\\n\\n  \").concat(pluginName, \".pluginName = '\").concat(pluginName, \"'\\n\"));\n  }\n\n  befores.forEach(function (before) {\n    var beforeIndex = plugins.findIndex(function (plugin) {\n      return plugin.pluginName === before;\n    });\n\n    if (beforeIndex > -1 && beforeIndex > pluginIndex) {\n      throw new Error(\"React Table: The \".concat(pluginName, \" plugin hook must be placed after the \").concat(before, \" plugin hook!\"));\n    }\n  });\n  afters.forEach(function (after) {\n    var afterIndex = plugins.findIndex(function (plugin) {\n      return plugin.pluginName === after;\n    });\n\n    if (afterIndex > -1 && afterIndex < pluginIndex) {\n      throw new Error(\"React Table: The \".concat(pluginName, \" plugin hook must be placed before the \").concat(after, \" plugin hook!\"));\n    }\n  });\n}\n\nfunction expandRows(rows, _ref3) {\n  var manualExpandedKey = _ref3.manualExpandedKey,\n      expanded = _ref3.expanded,\n      _ref3$expandSubRows = _ref3.expandSubRows,\n      expandSubRows = _ref3$expandSubRows === void 0 ? true : _ref3$expandSubRows;\n  var expandedRows = [];\n\n  var handleRow = function handleRow(row) {\n    var key = row.path.join('.');\n    row.isExpanded = row.original && row.original[manualExpandedKey] || expanded.includes(key);\n    row.canExpand = row.subRows && !!row.subRows.length;\n    expandedRows.push(row);\n\n    if (expandSubRows && row.subRows && row.subRows.length && row.isExpanded) {\n      row.subRows.forEach(handleRow);\n    }\n  };\n\n  rows.forEach(handleRow);\n  return expandedRows;\n} //\n\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj) // remove all periods in parts\n  .map(function (d) {\n    return String(d).replace('.', '_');\n  }) // join parts using period\n  .join('.') // replace brackets with periods\n  .replace(/\\[/g, '.').replace(/\\]/g, '') // split it back out on periods\n  .split('.');\n}\n\nfunction flattenDeep(arr) {\n  var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!Array.isArray(arr)) {\n    newArr.push(arr);\n  } else {\n    for (var i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr);\n    }\n  }\n\n  return newArr;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  defaultColumn: defaultColumn,\n  safeUseLayoutEffect: safeUseLayoutEffect,\n  findMaxDepth: findMaxDepth,\n  decorateColumn: decorateColumn,\n  decorateColumnTree: decorateColumnTree,\n  makeHeaderGroups: makeHeaderGroups,\n  determineHeaderVisibility: determineHeaderVisibility,\n  getBy: getBy,\n  defaultOrderByFn: defaultOrderByFn,\n  getFirstDefined: getFirstDefined,\n  defaultGroupByFn: defaultGroupByFn,\n  getElementDimensions: getElementDimensions,\n  flexRender: flexRender,\n  mergeProps: mergeProps,\n  applyHooks: applyHooks,\n  applyPropHooks: applyPropHooks,\n  warnUnknownProps: warnUnknownProps,\n  sum: sum,\n  isFunction: isFunction,\n  flattenBy: flattenBy,\n  ensurePluginOrder: ensurePluginOrder,\n  expandRows: expandRows\n});\nvar renderErr = 'You must specify a valid render component. This could be \"column.Cell\", \"column.Header\", \"column.Filter\", \"column.Aggregated\" or any other custom renderer component.';\nvar defaultState = {};\nvar defaultInitialState = {};\nvar defaultColumnInstance = {};\n\nvar defaultReducer = function defaultReducer(old, newState) {\n  return newState;\n};\n\nvar defaultGetSubRows = function defaultGetSubRows(row, index) {\n  return row.subRows || [];\n};\n\nvar defaultGetRowID = function defaultGetRowID(row, index) {\n  return index;\n};\n\nvar useTable = function useTable(props) {\n  // Destructure props\n  var data = props.data,\n      userColumns = props.columns,\n      _props$initialState = props.initialState,\n      initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState,\n      userState = props.state,\n      _props$defaultColumn = props.defaultColumn,\n      defaultColumn = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn,\n      _props$getSubRows = props.getSubRows,\n      getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows,\n      _props$getRowID = props.getRowID,\n      getRowID = _props$getRowID === void 0 ? defaultGetRowID : _props$getRowID,\n      _props$reducer = props.reducer,\n      reducer = _props$reducer === void 0 ? defaultReducer : _props$reducer,\n      debug = props.debug;\n  debug = process.env.NODE_ENV === 'production' ? false : debug; // But use the users table state if provided\n\n  var _React$useState = React.useState(_objectSpread2({}, defaultState, {}, initialState)),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      originalState = _React$useState2[0],\n      originalSetState = _React$useState2[1];\n\n  var state = React.useMemo(function () {\n    if (userState) {\n      var newState = _objectSpread2({}, originalState);\n\n      Object.keys(userState).forEach(function (key) {\n        newState[key] = userState[key];\n      });\n      return newState;\n    }\n\n    return originalState;\n  }, [originalState, userState]);\n  var setState = React.useCallback(function (updater, type) {\n    return originalSetState(function (old) {\n      var newState = typeof updater === 'function' ? updater(old) : updater;\n      return reducer(old, newState, type);\n    });\n  }, [reducer]); // The table instance ref\n\n  var instanceRef = React.useRef({});\n\n  for (var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    plugins[_key - 1] = arguments[_key];\n  }\n\n  Object.assign(instanceRef.current, _objectSpread2({}, props, {\n    data: data,\n    // The raw data\n    state: state,\n    setState: setState,\n    // The resolved table state\n    plugins: plugins,\n    // All resolved plugins\n    hooks: {\n      columnsBeforeHeaderGroups: [],\n      columnsBeforeHeaderGroupsDeps: [],\n      useBeforeDimensions: [],\n      useMain: [],\n      useRows: [],\n      prepareRow: [],\n      getTableProps: [],\n      getTableBodyProps: [],\n      getRowProps: [],\n      getHeaderGroupProps: [],\n      getHeaderProps: [],\n      getCellProps: []\n    }\n  })); // Allow plugins to register hooks\n\n  if (process.env.NODE_ENV === 'development' && debug) console.time('plugins');\n  plugins.filter(Boolean).forEach(function (plugin) {\n    plugin(instanceRef.current.hooks);\n  });\n  if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('plugins'); // Decorate All the columns\n\n  var columns = React.useMemo(function () {\n    return decorateColumnTree(userColumns, defaultColumn);\n  }, [defaultColumn, userColumns]); // Get the flat list of all columns and allow hooks to decorate\n  // those columns (and trigger this memoization via deps)\n\n  var flatColumns = React.useMemo(function () {\n    if (process.env.NODE_ENV === 'development' && debug) console.time('hooks.columnsBeforeHeaderGroups');\n    var newColumns = applyHooks(instanceRef.current.hooks.columnsBeforeHeaderGroups, flattenBy(columns, 'columns'), instanceRef.current);\n    if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('hooks.columnsBeforeHeaderGroups');\n    return newColumns;\n  }, [columns, debug].concat(_toConsumableArray(applyHooks(instanceRef.current.hooks.columnsBeforeHeaderGroupsDeps, [], instanceRef.current)))); // Make the headerGroups\n\n  var headerGroups = React.useMemo(function () {\n    return makeHeaderGroups(flatColumns, defaultColumn);\n  }, [defaultColumn, flatColumns]);\n  var headers = React.useMemo(function () {\n    return headerGroups[0].headers;\n  }, [headerGroups]);\n  Object.assign(instanceRef.current, {\n    columns: columns,\n    flatColumns: flatColumns,\n    headerGroups: headerGroups,\n    headers: headers\n  }); // Access the row model\n\n  var _React$useMemo = React.useMemo(function () {\n    if (process.env.NODE_ENV === 'development' && debug) console.time('getAccessedRows');\n    var flatRows = []; // Access the row's data\n\n    var accessRow = function accessRow(originalRow, i) {\n      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; // Keep the original reference around\n\n      var original = originalRow;\n      var rowID = getRowID(originalRow, i); // Make the new path for the row\n\n      var path = [].concat(_toConsumableArray(parentPath), [rowID]);\n      var row = {\n        original: original,\n        index: i,\n        path: path,\n        // used to create a key for each row even if not nested\n        depth: depth,\n        cells: [{}] // This is a dummy cell\n\n      };\n      flatRows.push(row); // Process any subRows\n\n      var subRows = getSubRows(originalRow, i);\n\n      if (subRows) {\n        row.subRows = subRows.map(function (d, i) {\n          return accessRow(d, i, depth + 1, path);\n        });\n      } // Override common array functions (and the dummy cell's getCellProps function)\n      // to show an error if it is accessed without calling prepareRow\n\n\n      var unpreparedAccessWarning = function unpreparedAccessWarning() {\n        throw new Error('React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.');\n      };\n\n      row.cells.map = unpreparedAccessWarning;\n      row.cells.filter = unpreparedAccessWarning;\n      row.cells.forEach = unpreparedAccessWarning;\n      row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values\n\n      row.values = {};\n      flatColumns.forEach(function (column) {\n        row.values[column.id] = column.accessor ? column.accessor(originalRow, i, {\n          subRows: subRows,\n          depth: depth,\n          data: data\n        }) : undefined;\n      });\n      return row;\n    }; // Use the resolved data\n\n\n    var accessedData = data.map(function (d, i) {\n      return accessRow(d, i);\n    });\n    if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('getAccessedRows');\n    return [accessedData, flatRows];\n  }, [debug, data, getRowID, getSubRows, flatColumns]),\n      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n      rows = _React$useMemo2[0],\n      flatRows = _React$useMemo2[1];\n\n  instanceRef.current.rows = rows;\n  instanceRef.current.flatRows = flatRows; // Determine column visibility\n\n  determineHeaderVisibility(instanceRef.current); // Provide a flat header list for utilities\n\n  instanceRef.current.flatHeaders = headerGroups.reduce(function (all, headerGroup) {\n    return [].concat(_toConsumableArray(all), _toConsumableArray(headerGroup.headers));\n  }, []);\n  if (process.env.NODE_ENV === 'development' && debug) console.time('hooks.useBeforeDimensions');\n  instanceRef.current = applyHooks(instanceRef.current.hooks.useBeforeDimensions, instanceRef.current);\n  if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('hooks.useBeforeDimensions');\n  calculateDimensions(instanceRef.current);\n  if (process.env.NODE_ENV === 'development' && debug) console.time('hooks.useMain');\n  instanceRef.current = applyHooks(instanceRef.current.hooks.useMain, instanceRef.current);\n  if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('hooks.useMain'); // Each materialized header needs to be assigned a render function and other\n  // prop getter properties here.\n\n  instanceRef.current.flatHeaders.forEach(function (column) {\n    // Give columns/headers rendering power\n    column.render = function (type) {\n      var userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var Comp = typeof type === 'string' ? column[type] : type;\n\n      if (typeof Comp === 'undefined') {\n        throw new Error(renderErr);\n      }\n\n      return flexRender(Comp, _objectSpread2({}, instanceRef.current, {\n        column: column\n      }, userProps));\n    }; // Give columns/headers a default getHeaderProps\n\n\n    column.getHeaderProps = function (props) {\n      return mergeProps({\n        key: ['header', column.id].join('_'),\n        colSpan: column.totalVisibleHeaderCount\n      }, applyPropHooks(instanceRef.current.hooks.getHeaderProps, column, instanceRef.current), props);\n    };\n  });\n  instanceRef.current.headerGroups.forEach(function (headerGroup, i) {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter(function (header) {\n      var recurse = function recurse(headers) {\n        return headers.filter(function (header) {\n          if (header.headers) {\n            return recurse(header.headers);\n          }\n\n          return header.isVisible;\n        }).length;\n      };\n\n      if (header.headers) {\n        return recurse(header.headers);\n      }\n\n      return header.isVisible;\n    }); // Give headerGroups getRowProps\n\n    if (headerGroup.headers.length) {\n      headerGroup.getHeaderGroupProps = function () {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return mergeProps({\n          key: [\"header\".concat(i)].join('_')\n        }, applyPropHooks(instanceRef.current.hooks.getHeaderGroupProps, headerGroup, instanceRef.current), props);\n      };\n\n      return true;\n    }\n  }); // Run the rows (this could be a dangerous hook with a ton of data)\n\n  if (process.env.NODE_ENV === 'development' && debug) console.time('hooks.useRows');\n  instanceRef.current.rows = applyHooks(instanceRef.current.hooks.useRows, instanceRef.current.rows, instanceRef.current);\n  if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('hooks.useRows'); // The prepareRow function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n\n  instanceRef.current.prepareRow = React.useCallback(function (row) {\n    row.getRowProps = function (props) {\n      return mergeProps({\n        key: ['row'].concat(_toConsumableArray(row.path)).join('_')\n      }, applyPropHooks(instanceRef.current.hooks.getRowProps, row, instanceRef.current), props);\n    }; // Build the visible cells for each row\n\n\n    row.cells = instanceRef.current.flatColumns.filter(function (d) {\n      return d.isVisible;\n    }).map(function (column) {\n      var cell = {\n        column: column,\n        row: row,\n        value: row.values[column.id]\n      }; // Give each cell a getCellProps base\n\n      cell.getCellProps = function (props) {\n        var columnPathStr = [].concat(_toConsumableArray(row.path), [column.id]).join('_');\n        return mergeProps({\n          key: ['cell', columnPathStr].join('_')\n        }, applyPropHooks(instanceRef.current.hooks.getCellProps, cell, instanceRef.current), props);\n      }; // Give each cell a renderer function (supports multiple renderers)\n\n\n      cell.render = function (type) {\n        var userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var Comp = typeof type === 'string' ? column[type] : type;\n\n        if (typeof Comp === 'undefined') {\n          throw new Error(renderErr);\n        }\n\n        return flexRender(Comp, _objectSpread2({}, instanceRef.current, {\n          column: column,\n          row: row,\n          cell: cell\n        }, userProps));\n      };\n\n      return cell;\n    }); // need to apply any row specific hooks (useExpanded requires this)\n\n    applyHooks(instanceRef.current.hooks.prepareRow, row, instanceRef.current);\n  }, []);\n\n  instanceRef.current.getTableProps = function (userProps) {\n    return mergeProps(applyPropHooks(instanceRef.current.hooks.getTableProps, instanceRef.current), userProps);\n  };\n\n  instanceRef.current.getTableBodyProps = function (userProps) {\n    return mergeProps(applyPropHooks(instanceRef.current.hooks.getTableBodyProps, instanceRef.current), userProps);\n  };\n\n  return instanceRef.current;\n};\n\nfunction calculateDimensions(instance) {\n  var headers = instance.headers;\n  instance.totalColumnsWidth = calculateHeaderWidths(headers);\n}\n\nfunction calculateHeaderWidths(headers) {\n  var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var sumTotalWidth = 0;\n  headers.forEach(function (header) {\n    var subHeaders = header.headers;\n    header.totalLeft = left;\n\n    if (subHeaders && subHeaders.length) {\n      header.totalWidth = calculateHeaderWidths(subHeaders, left);\n    } else {\n      header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);\n    }\n\n    if (header.isVisible) {\n      left += header.totalWidth;\n      sumTotalWidth += header.totalWidth;\n    }\n  });\n  return sumTotalWidth;\n}\n\nvar actions = {};\n\nvar addActions = function addActions() {\n  for (var _len = arguments.length, acts = new Array(_len), _key = 0; _key < _len; _key++) {\n    acts[_key] = arguments[_key];\n  }\n\n  acts.forEach(function (action) {\n    // Action values are formatted this way to discourage\n    // you (the dev) from interacting with them in any way\n    // other than importing `{ actions } from 'react-table'`\n    // and referencing an action via `actions[actionName]`\n    actions[action] = \"React Table Action: \".concat(action);\n  });\n};\n\ndefaultState.expanded = [];\naddActions('toggleExpanded', 'useExpanded');\n\nvar useExpanded = function useExpanded(hooks) {\n  hooks.getExpandedToggleProps = [];\n  hooks.useMain.push(useMain);\n};\n\nuseExpanded.pluginName = 'useExpanded';\n\nvar defaultGetResetExpandedDeps = function defaultGetResetExpandedDeps(instance) {\n  return [instance.data];\n};\n\nfunction useMain(instance) {\n  var debug = instance.debug,\n      rows = instance.rows,\n      _instance$manualExpan = instance.manualExpandedKey,\n      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,\n      _instance$paginateExp = instance.paginateExpandedRows,\n      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,\n      _instance$expandSubRo = instance.expandSubRows,\n      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,\n      hooks = instance.hooks,\n      expanded = instance.state.expanded,\n      setState = instance.setState,\n      _instance$getResetExp = instance.getResetExpandedDeps,\n      getResetExpandedDeps = _instance$getResetExp === void 0 ? defaultGetResetExpandedDeps : _instance$getResetExp; // Bypass any effects from firing when this changes\n\n  var isMountedRef = React.useRef();\n  safeUseLayoutEffect(function () {\n    if (isMountedRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          expanded: []\n        });\n      }, actions.pageChange);\n    }\n\n    isMountedRef.current = true;\n  }, [setState].concat(_toConsumableArray(getResetExpandedDeps ? getResetExpandedDeps(instance) : [])));\n\n  var toggleExpandedByPath = function toggleExpandedByPath(path, set) {\n    var key = path.join('.');\n    return setState(function (old) {\n      var exists = old.expanded.includes(key);\n      var shouldExist = typeof set !== 'undefined' ? set : !exists;\n      var newExpanded = new Set(old.expanded);\n\n      if (!exists && shouldExist) {\n        newExpanded.add(key);\n      } else if (exists && !shouldExist) {\n        newExpanded.delete(key);\n      } else {\n        return old;\n      }\n\n      return _objectSpread2({}, old, {\n        expanded: _toConsumableArray(newExpanded.values())\n      });\n    }, actions.toggleExpanded);\n  };\n\n  hooks.prepareRow.push(function (row) {\n    row.toggleExpanded = function (set) {\n      return toggleExpandedByPath(row.path, set);\n    };\n\n    row.getExpandedToggleProps = function (props) {\n      return mergeProps({\n        onClick: function onClick(e) {\n          e.persist();\n          row.toggleExpanded();\n        },\n        style: {\n          cursor: 'pointer'\n        },\n        title: 'Toggle Expanded'\n      }, applyPropHooks(instance.hooks.getExpandedToggleProps, row, instance), props);\n    };\n\n    return row;\n  });\n  var expandedRows = React.useMemo(function () {\n    if (process.env.NODE_ENV === 'development' && debug) console.info('getExpandedRows');\n\n    if (paginateExpandedRows) {\n      return expandRows(rows, {\n        manualExpandedKey: manualExpandedKey,\n        expanded: expanded,\n        expandSubRows: expandSubRows\n      });\n    }\n\n    return rows;\n  }, [debug, paginateExpandedRows, rows, manualExpandedKey, expanded, expandSubRows]);\n  var expandedDepth = findExpandedDepth(expanded);\n  return _objectSpread2({}, instance, {\n    toggleExpandedByPath: toggleExpandedByPath,\n    expandedDepth: expandedDepth,\n    rows: expandedRows\n  });\n}\n\nfunction findExpandedDepth(expanded) {\n  var maxDepth = 0;\n  expanded.forEach(function (key) {\n    var path = key.split('.');\n    maxDepth = Math.max(maxDepth, path.length);\n  });\n  return maxDepth;\n}\n\nvar text = function text(rows, id, filterValue) {\n  rows = rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());\n  });\n  return rows;\n};\n\ntext.autoRemove = function (val) {\n  return !val;\n};\n\nvar exactText = function exactText(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;\n  });\n};\n\nexactText.autoRemove = function (val) {\n  return !val;\n};\n\nvar exactTextCase = function exactTextCase(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;\n  });\n};\n\nexactTextCase.autoRemove = function (val) {\n  return !val;\n};\n\nvar includes = function includes(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return filterValue.includes(rowValue);\n  });\n};\n\nincludes.autoRemove = function (val) {\n  return !val || !val.length;\n};\n\nvar includesAll = function includesAll(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue && rowValue.length && filterValue.every(function (val) {\n      return rowValue.includes(val);\n    });\n  });\n};\n\nincludesAll.autoRemove = function (val) {\n  return !val || !val.length;\n};\n\nvar exact = function exact(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue === filterValue;\n  });\n};\n\nexact.autoRemove = function (val) {\n  return typeof val === 'undefined';\n};\n\nvar equals = function equals(rows, id, filterValue) {\n  return rows.filter(function (row) {\n    var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq\n\n    return rowValue == filterValue;\n  });\n};\n\nequals.autoRemove = function (val) {\n  return val == null;\n};\n\nvar between = function between(rows, id, filterValue) {\n  var _ref = filterValue || [],\n      _ref2 = _slicedToArray(_ref, 2),\n      min = _ref2[0],\n      max = _ref2[1];\n\n  min = typeof min === 'number' ? min : -Infinity;\n  max = typeof max === 'number' ? max : Infinity;\n\n  if (min > max) {\n    var temp = min;\n    min = max;\n    max = temp;\n  }\n\n  return rows.filter(function (row) {\n    var rowValue = row.values[id];\n    return rowValue >= min && rowValue <= max;\n  });\n};\n\nbetween.autoRemove = function (val) {\n  return !val || typeof val[0] !== 'number' && typeof val[1] !== 'number';\n};\n\nvar filterTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  text: text,\n  exactText: exactText,\n  exactTextCase: exactTextCase,\n  includes: includes,\n  includesAll: includesAll,\n  exact: exact,\n  equals: equals,\n  between: between\n});\ndefaultState.filters = {};\naddActions('setFilter', 'setAllFilters');\n\nvar useFilters = function useFilters(hooks) {\n  hooks.useMain.push(useMain$1);\n};\n\nuseFilters.pluginName = 'useFilters';\n\nfunction useMain$1(instance) {\n  var debug = instance.debug,\n      rows = instance.rows,\n      flatRows = instance.flatRows,\n      flatColumns = instance.flatColumns,\n      userFilterTypes = instance.filterTypes,\n      manualFilters = instance.manualFilters,\n      _instance$defaultCanF = instance.defaultCanFilter,\n      defaultCanFilter = _instance$defaultCanF === void 0 ? false : _instance$defaultCanF,\n      disableFilters = instance.disableFilters,\n      filters = instance.state.filters,\n      setState = instance.setState,\n      _instance$getResetFil = instance.getResetFiltersDeps,\n      getResetFiltersDeps = _instance$getResetFil === void 0 ? false : _instance$getResetFil;\n  var preFilteredRows = rows;\n  var preFilteredFlatRows = flatRows; // Bypass any effects from firing when this changes\n\n  var isMountedRef = React.useRef();\n  safeUseLayoutEffect(function () {\n    if (isMountedRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          filters: {}\n        });\n      }, actions.pageChange);\n    }\n\n    isMountedRef.current = true;\n  }, [setState].concat(_toConsumableArray(getResetFiltersDeps ? getResetFiltersDeps(instance) : [])));\n\n  var setFilter = function setFilter(id, updater) {\n    var column = flatColumns.find(function (d) {\n      return d.id === id;\n    });\n\n    if (!column) {\n      throw new Error(\"React-Table: Could not find a column with id: \".concat(id));\n    }\n\n    var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n    return setState(function (old) {\n      var newFilter = typeof updater === 'function' ? updater(old.filters[id]) : updater; //\n\n      if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {\n        var _old$filters = old.filters,\n            remove = _old$filters[id],\n            newFilters = _objectWithoutProperties(_old$filters, [id].map(_toPropertyKey));\n\n        return _objectSpread2({}, old, {\n          filters: newFilters\n        });\n      }\n\n      return _objectSpread2({}, old, {\n        filters: _objectSpread2({}, old.filters, _defineProperty({}, id, newFilter))\n      });\n    }, actions.setFilter);\n  };\n\n  var setAllFilters = function setAllFilters(updater) {\n    return setState(function (old) {\n      var newFilters = typeof updater === 'function' ? updater(old) : updater; // Filter out undefined values\n\n      Object.keys(newFilters).forEach(function (id) {\n        var newFilter = newFilters[id];\n        var column = flatColumns.find(function (d) {\n          return d.id === id;\n        });\n        var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n\n        if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {\n          delete newFilters[id];\n        }\n      });\n      return _objectSpread2({}, old, {\n        filters: newFilters\n      });\n    }, actions.setAllFilters);\n  };\n\n  flatColumns.forEach(function (column) {\n    var id = column.id,\n        accessor = column.accessor,\n        columnDefaultCanFilter = column.defaultCanFilter,\n        columnDisableFilters = column.disableFilters; // Determine if a column is filterable\n\n    column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value\n\n    column.setFilter = function (val) {\n      return setFilter(column.id, val);\n    }; // Provide the current filter value to the column for\n    // convenience\n\n\n    column.filterValue = filters[id];\n  }); // TODO: Create a filter cache for incremental high speed multi-filtering\n  // This gets pretty complicated pretty fast, since you have to maintain a\n  // cache for each row group (top-level rows, and each row's recursive subrows)\n  // This would make multi-filtering a lot faster though. Too far?\n\n  var _React$useMemo = React.useMemo(function () {\n    if (manualFilters || !Object.keys(filters).length) {\n      return {\n        filteredRows: rows,\n        filteredFlatRows: flatRows\n      };\n    }\n\n    var filteredFlatRows = [];\n    if (process.env.NODE_ENV === 'development' && debug) console.info('getFilteredRows'); // Filters top level and nested rows\n\n    var filterRows = function filterRows(rows) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var filteredRows = rows;\n      filteredRows = Object.entries(filters).reduce(function (filteredSoFar, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            columnID = _ref2[0],\n            filterValue = _ref2[1]; // Find the filters column\n\n\n        var column = flatColumns.find(function (d) {\n          return d.id === columnID;\n        });\n\n        if (!column) {\n          return filteredSoFar;\n        }\n\n        if (depth === 0) {\n          column.preFilteredRows = filteredSoFar;\n        }\n\n        var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n\n        if (!filterMethod) {\n          console.warn(\"Could not find a valid 'column.filter' for column with the ID: \".concat(column.id, \".\"));\n          return filteredSoFar;\n        } // Pass the rows, id, filterValue and column to the filterMethod\n        // to get the filtered rows back\n\n\n        column.filteredRows = filterMethod(filteredSoFar, columnID, filterValue, column);\n        return column.filteredRows;\n      }, rows); // Apply the filter to any subRows\n      // We technically could do this recursively in the above loop,\n      // but that would severely hinder the API for the user, since they\n      // would be required to do that recursion in some scenarios\n\n      filteredRows = filteredRows.map(function (row) {\n        filteredFlatRows.push(row);\n\n        if (!row.subRows) {\n          return row;\n        }\n\n        return _objectSpread2({}, row, {\n          subRows: row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows\n        });\n      });\n      return filteredRows;\n    };\n\n    return {\n      filteredRows: filterRows(rows),\n      filteredFlatRows: filteredFlatRows\n    };\n  }, [manualFilters, filters, debug, rows, flatRows, flatColumns, userFilterTypes]),\n      filteredRows = _React$useMemo.filteredRows,\n      filteredFlatRows = _React$useMemo.filteredFlatRows;\n\n  React.useMemo(function () {\n    // Now that each filtered column has it's partially filtered rows,\n    // lets assign the final filtered rows to all of the other columns\n    var nonFilteredColumns = flatColumns.filter(function (column) {\n      return !Object.keys(filters).includes(column.id);\n    }); // This essentially enables faceted filter options to be built easily\n    // using every column's preFilteredRows value\n\n    nonFilteredColumns.forEach(function (column) {\n      column.preFilteredRows = filteredRows;\n      column.filteredRows = filteredRows;\n    });\n  }, [filteredRows, filters, flatColumns]);\n  return _objectSpread2({}, instance, {\n    setFilter: setFilter,\n    setAllFilters: setAllFilters,\n    preFilteredRows: preFilteredRows,\n    preFilteredFlatRows: preFilteredFlatRows,\n    rows: filteredRows,\n    flatRows: filteredFlatRows\n  });\n}\n\nfunction shouldAutoRemove(autoRemove, value) {\n  return autoRemove ? autoRemove(value) : typeof value === 'undefined';\n}\n\nfunction getFilterMethod(filter, userFilterTypes, filterTypes) {\n  return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;\n}\n\nfunction sum$1(values, rows) {\n  return values.reduce(function (sum, next) {\n    return sum + next;\n  }, 0);\n}\n\nfunction average(values, rows) {\n  return Math.round(sum$1(values) / values.length * 100) / 100;\n}\n\nfunction median(values) {\n  values = values.length ? values : [0];\n  var min = Math.min.apply(Math, _toConsumableArray(values));\n  var max = Math.max.apply(Math, _toConsumableArray(values));\n  return (min + max) / 2;\n}\n\nfunction uniqueCount(values) {\n  return new Set(values).size;\n}\n\nfunction count(values) {\n  return values.length;\n}\n\nvar aggregations = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sum: sum$1,\n  average: average,\n  median: median,\n  uniqueCount: uniqueCount,\n  count: count\n});\ndefaultState.groupBy = [];\naddActions('toggleGroupBy');\n\nvar useGroupBy = function useGroupBy(hooks) {\n  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups);\n  hooks.columnsBeforeHeaderGroupsDeps.push(function (deps, instance) {\n    deps.push(instance.state.groupBy);\n    return deps;\n  });\n  hooks.useMain.push(useMain$2);\n};\n\nuseGroupBy.pluginName = 'useGroupBy';\n\nfunction columnsBeforeHeaderGroups(flatColumns, _ref) {\n  var groupBy = _ref.state.groupBy; // Sort grouped columns to the start of the column list\n  // before the headers are built\n\n  var groupByColumns = groupBy.map(function (g) {\n    return flatColumns.find(function (col) {\n      return col.id === g;\n    });\n  });\n  var nonGroupByColumns = flatColumns.filter(function (col) {\n    return !groupBy.includes(col.id);\n  }); // If a groupByBoundary column is found, place the groupBy's after it\n\n  var groupByBoundaryColumnIndex = flatColumns.findIndex(function (column) {\n    return column.groupByBoundary;\n  }) + 1;\n  return [].concat(_toConsumableArray(nonGroupByColumns.slice(0, groupByBoundaryColumnIndex)), _toConsumableArray(groupByColumns), _toConsumableArray(nonGroupByColumns.slice(groupByBoundaryColumnIndex)));\n}\n\nfunction useMain$2(instance) {\n  var debug = instance.debug,\n      rows = instance.rows,\n      flatColumns = instance.flatColumns,\n      flatHeaders = instance.flatHeaders,\n      _instance$groupByFn = instance.groupByFn,\n      groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn,\n      manualGroupBy = instance.manualGroupBy,\n      defaultCanGroupBy = instance.defaultCanGroupBy,\n      disableGroupBy = instance.disableGroupBy,\n      _instance$aggregation = instance.aggregations,\n      userAggregations = _instance$aggregation === void 0 ? {} : _instance$aggregation,\n      hooks = instance.hooks,\n      plugins = instance.plugins,\n      groupBy = instance.state.groupBy,\n      setState = instance.setState;\n  ensurePluginOrder(plugins, [], 'useGroupBy', ['useSortBy', 'useExpanded']);\n  flatColumns.forEach(function (column) {\n    var id = column.id,\n        accessor = column.accessor,\n        defaultColumnGroupBy = column.defaultGroupBy,\n        columnDisableGroupBy = column.disableGroupBy;\n    column.isGrouped = groupBy.includes(id);\n    column.groupedIndex = groupBy.indexOf(id);\n    column.canGroupBy = accessor ? getFirstDefined(columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(defaultColumnGroupBy, defaultCanGroupBy, false);\n\n    if (column.canGroupBy) {\n      column.toggleGroupBy = function () {\n        return toggleGroupBy(column.id);\n      };\n    }\n\n    column.Aggregated = column.Aggregated || column.Cell;\n  });\n\n  var toggleGroupBy = function toggleGroupBy(id, toggle) {\n    return setState(function (old) {\n      var resolvedToggle = typeof toggle !== 'undefined' ? toggle : !groupBy.includes(id);\n\n      if (resolvedToggle) {\n        return _objectSpread2({}, old, {\n          groupBy: [].concat(_toConsumableArray(groupBy), [id])\n        });\n      }\n\n      return _objectSpread2({}, old, {\n        groupBy: groupBy.filter(function (d) {\n          return d !== id;\n        })\n      });\n    }, actions.toggleGroupBy);\n  };\n\n  hooks.getGroupByToggleProps = [];\n  flatHeaders.forEach(function (header) {\n    var canGroupBy = header.canGroupBy;\n\n    header.getGroupByToggleProps = function (props) {\n      return mergeProps({\n        onClick: canGroupBy ? function (e) {\n          e.persist();\n          header.toggleGroupBy();\n        } : undefined,\n        style: {\n          cursor: canGroupBy ? 'pointer' : undefined\n        },\n        title: 'Toggle GroupBy'\n      }, applyPropHooks(instance.hooks.getGroupByToggleProps, header, instance), props);\n    };\n  });\n  hooks.prepareRow.push(function (row) {\n    row.cells.forEach(function (cell) {\n      // Grouped cells are in the groupBy and the pivot cell for the row\n      cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Repeated cells are any columns in the groupBy that are not grouped\n\n      cell.isRepeatedValue = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows\n\n      cell.isAggregated = !cell.isGrouped && !cell.isRepeatedValue && row.canExpand;\n    });\n    return row;\n  });\n  var groupedRows = React.useMemo(function () {\n    if (manualGroupBy || !groupBy.length) {\n      return rows;\n    }\n\n    if (process.env.NODE_ENV === 'development' && debug) console.info('getGroupedRows'); // Find the columns that can or are aggregating\n    // Uses each column to aggregate rows into a single value\n\n    var aggregateRowsToValues = function aggregateRowsToValues(rows, isSourceRows) {\n      var values = {};\n      flatColumns.forEach(function (column) {\n        // Don't aggregate columns that are in the groupBy\n        if (groupBy.includes(column.id)) {\n          values[column.id] = rows[0] ? rows[0].values[column.id] : null;\n          return;\n        }\n\n        var columnValues = rows.map(function (d) {\n          return d.values[column.id];\n        });\n        var aggregator = column.aggregate;\n\n        if (Array.isArray(aggregator)) {\n          if (aggregator.length !== 2) {\n            console.info({\n              column: column\n            });\n            throw new Error(\"React Table: Complex aggregators must have 2 values, eg. aggregate: ['sum', 'count']. More info above...\");\n          }\n\n          if (isSourceRows) {\n            aggregator = aggregator[1];\n          } else {\n            aggregator = aggregator[0];\n          }\n        }\n\n        var aggregateFn = typeof aggregator === 'function' ? aggregator : userAggregations[aggregator] || aggregations[aggregator];\n\n        if (aggregateFn) {\n          values[column.id] = aggregateFn(columnValues, rows);\n        } else if (aggregator) {\n          console.info({\n            column: column\n          });\n          throw new Error(\"React Table: Invalid aggregate option for column listed above\");\n        } else {\n          values[column.id] = null;\n        }\n      });\n      return values;\n    }; // Recursively group the data\n\n\n    var groupRecursively = function groupRecursively(rows) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : []; // This is the last level, just return the rows\n\n      if (depth >= groupBy.length) {\n        return rows;\n      }\n\n      var columnID = groupBy[depth]; // Group the rows together for this level\n\n      var groupedRows = groupByFn(rows, columnID); // Recurse to sub rows before aggregation\n\n      groupedRows = Object.entries(groupedRows).map(function (_ref2, index) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            groupByVal = _ref3[0],\n            subRows = _ref3[1];\n\n        var path = [].concat(_toConsumableArray(parentPath), [\"\".concat(columnID, \":\").concat(groupByVal)]);\n        subRows = groupRecursively(subRows, depth + 1, path);\n        var values = aggregateRowsToValues(subRows, depth + 1 >= groupBy.length);\n        var row = {\n          isAggregated: true,\n          groupByID: columnID,\n          groupByVal: groupByVal,\n          values: values,\n          subRows: subRows,\n          depth: depth,\n          index: index,\n          path: path\n        };\n        return row;\n      });\n      return groupedRows;\n    }; // Assign the new data\n\n\n    return groupRecursively(rows);\n  }, [manualGroupBy, groupBy, debug, rows, flatColumns, userAggregations, groupByFn]);\n  return _objectSpread2({}, instance, {\n    toggleGroupBy: toggleGroupBy,\n    rows: groupedRows,\n    preGroupedRows: rows\n  });\n}\n\nvar reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\n\nvar alphanumeric = function alphanumeric(rowA, rowB, columnID) {\n  var a = getRowValueByColumnID(rowA, columnID);\n  var b = getRowValueByColumnID(rowB, columnID); // Force to strings (or \"\" for unsupported types)\n\n  a = toString(a);\n  b = toString(b); // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n\n  a = a.split(reSplitAlphaNumeric).filter(Boolean);\n  b = b.split(reSplitAlphaNumeric).filter(Boolean); // While\n\n  while (a.length && b.length) {\n    var aa = a.shift();\n    var bb = b.shift();\n    var an = parseInt(aa, 10);\n    var bn = parseInt(bb, 10);\n    var combo = [an, bn].sort(); // Both are string\n\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1;\n      }\n\n      if (bb > aa) {\n        return -1;\n      }\n\n      continue;\n    } // One is a string, one is a number\n\n\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1;\n    } // Both are numbers\n\n\n    if (an > bn) {\n      return 1;\n    }\n\n    if (bn > an) {\n      return -1;\n    }\n  }\n\n  return a.length - b.length;\n};\n\nfunction datetime(rowA, rowB, columnID) {\n  var a = getRowValueByColumnID(rowA, columnID);\n  var b = getRowValueByColumnID(rowB, columnID);\n  a = a.getTime();\n  b = b.getTime();\n  return compareBasic(a, b);\n}\n\nfunction basic(rowA, rowB, columnID) {\n  var a = getRowValueByColumnID(rowA, columnID);\n  var b = getRowValueByColumnID(rowB, columnID);\n  return compareBasic(a, b);\n} // Utils\n\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction getRowValueByColumnID(row, columnID) {\n  return row.values[columnID];\n}\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return '';\n    }\n\n    return String(a);\n  }\n\n  if (typeof a === 'string') {\n    return a;\n  }\n\n  return '';\n}\n\nvar sortTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  alphanumeric: alphanumeric,\n  datetime: datetime,\n  basic: basic\n});\ndefaultState.sortBy = [];\ndefaultColumn.sortType = 'alphanumeric';\ndefaultColumn.sortDescFirst = false;\naddActions('sortByChange');\n\nvar useSortBy = function useSortBy(hooks) {\n  hooks.useMain.push(useMain$3);\n};\n\nuseSortBy.pluginName = 'useSortBy';\n\nfunction useMain$3(instance) {\n  var debug = instance.debug,\n      rows = instance.rows,\n      flatColumns = instance.flatColumns,\n      _instance$orderByFn = instance.orderByFn,\n      orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn,\n      userSortTypes = instance.sortTypes,\n      manualSorting = instance.manualSorting,\n      defaultCanSort = instance.defaultCanSort,\n      disableSortBy = instance.disableSortBy,\n      disableSortRemove = instance.disableSortRemove,\n      disableMultiRemove = instance.disableMultiRemove,\n      disableMultiSort = instance.disableMultiSort,\n      _instance$isMultiSort = instance.isMultiSortEvent,\n      isMultiSortEvent = _instance$isMultiSort === void 0 ? function (e) {\n    return e.shiftKey;\n  } : _instance$isMultiSort,\n      _instance$maxMultiSor = instance.maxMultiSortColCount,\n      maxMultiSortColCount = _instance$maxMultiSor === void 0 ? Number.MAX_SAFE_INTEGER : _instance$maxMultiSor,\n      flatHeaders = instance.flatHeaders,\n      hooks = instance.hooks,\n      sortBy = instance.state.sortBy,\n      setState = instance.setState,\n      plugins = instance.plugins,\n      _instance$getResetSor = instance.getResetSortByDeps,\n      getResetSortByDeps = _instance$getResetSor === void 0 ? false : _instance$getResetSor;\n  ensurePluginOrder(plugins, ['useFilters'], 'useSortBy', []); // Add custom hooks\n\n  hooks.getSortByToggleProps = []; // Bypass any effects from firing when this changes\n\n  var isMountedRef = React.useRef();\n  safeUseLayoutEffect(function () {\n    if (isMountedRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          sortBy: []\n        });\n      }, actions.pageChange);\n    }\n\n    isMountedRef.current = true;\n  }, [setState].concat(_toConsumableArray(getResetSortByDeps ? getResetSortByDeps(instance) : []))); // Updates sorting based on a columnID, desc flag and multi flag\n\n  var toggleSortBy = function toggleSortBy(columnID, desc, multi) {\n    return setState(function (old) {\n      var sortBy = old.sortBy; // Find the column for this columnID\n\n      var column = flatColumns.find(function (d) {\n        return d.id === columnID;\n      });\n      var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column\n\n      var existingSortBy = sortBy.find(function (d) {\n        return d.id === columnID;\n      });\n      var existingIndex = sortBy.findIndex(function (d) {\n        return d.id === columnID;\n      });\n      var hasDescDefined = typeof desc !== 'undefined' && desc !== null;\n      var newSortBy = []; // What should we do with this sort action?\n\n      var action;\n\n      if (!disableMultiSort && multi) {\n        if (existingSortBy) {\n          action = 'toggle';\n        } else {\n          action = 'add';\n        }\n      } else {\n        // Normal mode\n        if (existingIndex !== sortBy.length - 1) {\n          action = 'replace';\n        } else if (existingSortBy) {\n          action = 'toggle';\n        } else {\n          action = 'replace';\n        }\n      } // Handle toggle states that will remove the sortBy\n\n\n      if (action === 'toggle' && // Must be toggling\n      !disableSortRemove && // If disableSortRemove, disable in general\n      !hasDescDefined && ( // Must not be setting desc\n      multi ? !disableMultiRemove : true) && ( // If multi, don't allow if disableMultiRemove\n      existingSortBy && // Finally, detect if it should indeed be removed\n      existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {\n        action = 'remove';\n      }\n\n      if (action === 'replace') {\n        newSortBy = [{\n          id: columnID,\n          desc: hasDescDefined ? desc : sortDescFirst\n        }];\n      } else if (action === 'add') {\n        newSortBy = [].concat(_toConsumableArray(sortBy), [{\n          id: columnID,\n          desc: hasDescDefined ? desc : sortDescFirst\n        }]); // Take latest n columns\n\n        newSortBy.splice(0, newSortBy.length - maxMultiSortColCount);\n      } else if (action === 'toggle') {\n        // This flips (or sets) the\n        newSortBy = sortBy.map(function (d) {\n          if (d.id === columnID) {\n            return _objectSpread2({}, d, {\n              desc: hasDescDefined ? desc : !existingSortBy.desc\n            });\n          }\n\n          return d;\n        });\n      } else if (action === 'remove') {\n        newSortBy = sortBy.filter(function (d) {\n          return d.id !== columnID;\n        });\n      }\n\n      return _objectSpread2({}, old, {\n        sortBy: newSortBy\n      });\n    }, actions.sortByChange);\n  }; // Add the getSortByToggleProps method to columns and headers\n\n\n  flatHeaders.forEach(function (column) {\n    var accessor = column.accessor,\n        defaultColumnCanSort = column.canSort,\n        columnDisableSortBy = column.disableSortBy,\n        id = column.id;\n    var canSort = accessor ? getFirstDefined(columnDisableSortBy === true ? false : undefined, disableSortBy === true ? false : undefined, true) : getFirstDefined(defaultCanSort, defaultColumnCanSort, false);\n    column.canSort = canSort;\n\n    if (column.canSort) {\n      column.toggleSortBy = function (desc, multi) {\n        return toggleSortBy(column.id, desc, multi);\n      };\n\n      column.clearSorting = function () {\n        return setState(function (old) {\n          var sortBy = old.sortBy;\n          var newSortBy = sortBy.filter(function (d) {\n            return d.id !== column.id;\n          });\n          return _objectSpread2({}, old, {\n            sortBy: newSortBy\n          });\n        }, actions.sortByChange);\n      };\n    }\n\n    column.getSortByToggleProps = function (props) {\n      return mergeProps({\n        onClick: canSort ? function (e) {\n          e.persist();\n          column.toggleSortBy(undefined, !instance.disableMultiSort && isMultiSortEvent(e));\n        } : undefined,\n        style: {\n          cursor: canSort ? 'pointer' : undefined\n        },\n        title: 'Toggle SortBy'\n      }, applyPropHooks(instance.hooks.getSortByToggleProps, column, instance), props);\n    };\n\n    var columnSort = sortBy.find(function (d) {\n      return d.id === id;\n    });\n    column.isSorted = !!columnSort;\n    column.sortedIndex = sortBy.findIndex(function (d) {\n      return d.id === id;\n    });\n    column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;\n  });\n  var sortedRows = React.useMemo(function () {\n    if (manualSorting || !sortBy.length) {\n      return rows;\n    }\n\n    if (process.env.NODE_ENV === 'development' && debug) console.time('getSortedRows'); // Filter out sortBys that correspond to non existing columns\n\n    var availableSortBy = sortBy.filter(function (sort) {\n      return flatColumns.find(function (col) {\n        return col.id === sort.id;\n      });\n    });\n\n    var sortData = function sortData(rows) {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      var sortedData = orderByFn(rows, availableSortBy.map(function (sort) {\n        // Support custom sorting methods for each column\n        var column = flatColumns.find(function (d) {\n          return d.id === sort.id;\n        });\n\n        if (!column) {\n          throw new Error(\"React-Table: Could not find a column with id: \".concat(sort.id, \" while sorting\"));\n        }\n\n        var sortType = column.sortType; // Look up sortBy functions in this order:\n        // column function\n        // column string lookup on user sortType\n        // column string lookup on built-in sortType\n        // default function\n        // default string lookup on user sortType\n        // default string lookup on built-in sortType\n\n        var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];\n\n        if (!sortMethod) {\n          throw new Error(\"React-Table: Could not find a valid sortType of '\".concat(sortType, \"' for column '\").concat(sort.id, \"'.\"));\n        } // Return the correct sortFn.\n        // This function should always return in ascending order\n\n\n        return function (a, b) {\n          return sortMethod(a, b, sort.id);\n        };\n      }), // Map the directions\n      availableSortBy.map(function (sort) {\n        // Detect and use the sortInverted option\n        var column = flatColumns.find(function (d) {\n          return d.id === sort.id;\n        });\n\n        if (column && column.sortInverted) {\n          return sort.desc;\n        }\n\n        return !sort.desc;\n      })); // If there are sub-rows, sort them\n\n      sortedData.forEach(function (row) {\n        if (!row.subRows || row.subRows.length <= 1) {\n          return;\n        }\n\n        row.subRows = sortData(row.subRows);\n      });\n      return sortedData;\n    };\n\n    if (process.env.NODE_ENV === 'development' && debug) console.timeEnd('getSortedRows');\n    return sortData(rows);\n  }, [manualSorting, sortBy, debug, rows, flatColumns, orderByFn, userSortTypes]);\n  return _objectSpread2({}, instance, {\n    toggleSortBy: toggleSortBy,\n    rows: sortedRows,\n    preSortedRows: rows\n  });\n}\n\ndefaultState.pageSize = 10;\ndefaultState.pageIndex = 0;\naddActions('pageChange', 'pageSizeChange');\n\nvar usePagination = function usePagination(hooks) {\n  hooks.useMain.push(useMain$4);\n};\n\nusePagination.pluginName = 'usePagination';\n\nvar defaultGetResetPageDeps = function defaultGetResetPageDeps(_ref) {\n  var rows = _ref.rows,\n      manualPagination = _ref.manualPagination,\n      _ref$state = _ref.state,\n      filters = _ref$state.filters,\n      groupBy = _ref$state.groupBy,\n      sortBy = _ref$state.sortBy;\n  return [manualPagination ? null : rows, filters, groupBy, sortBy];\n};\n\nfunction useMain$4(instance) {\n  var rows = instance.rows,\n      manualPagination = instance.manualPagination,\n      _instance$getResetPag = instance.getResetPageDeps,\n      getResetPageDeps = _instance$getResetPag === void 0 ? defaultGetResetPageDeps : _instance$getResetPag,\n      _instance$manualExpan = instance.manualExpandedKey,\n      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,\n      debug = instance.debug,\n      plugins = instance.plugins,\n      userPageCount = instance.pageCount,\n      _instance$paginateExp = instance.paginateExpandedRows,\n      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,\n      _instance$expandSubRo = instance.expandSubRows,\n      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,\n      _instance$state = instance.state,\n      pageSize = _instance$state.pageSize,\n      pageIndex = _instance$state.pageIndex,\n      expanded = _instance$state.expanded,\n      setState = instance.setState;\n  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'], 'usePagination', []); // Bypass any effects from firing when this changes\n\n  var isMountedRef = React.useRef();\n  safeUseLayoutEffect(function () {\n    if (isMountedRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          pageIndex: 0\n        });\n      }, actions.pageChange);\n    }\n\n    isMountedRef.current = true;\n  }, [setState].concat(_toConsumableArray(getResetPageDeps ? getResetPageDeps(instance) : [])));\n  var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);\n  var pageOptions = React.useMemo(function () {\n    return pageCount > 0 ? _toConsumableArray(new Array(pageCount)).map(function (d, i) {\n      return i;\n    }) : [];\n  }, [pageCount]);\n  var page = React.useMemo(function () {\n    var page;\n\n    if (manualPagination) {\n      page = rows;\n    } else {\n      if (process.env.NODE_ENV === 'development' && debug) console.info('getPage');\n      var pageStart = pageSize * pageIndex;\n      var pageEnd = pageStart + pageSize;\n      page = rows.slice(pageStart, pageEnd);\n    }\n\n    if (paginateExpandedRows) {\n      return page;\n    }\n\n    return expandRows(page, {\n      manualExpandedKey: manualExpandedKey,\n      expanded: expanded,\n      expandSubRows: expandSubRows\n    });\n  }, [debug, expandSubRows, expanded, manualExpandedKey, manualPagination, pageIndex, pageSize, paginateExpandedRows, rows]);\n  var canPreviousPage = pageIndex > 0;\n  var canNextPage = pageCount === -1 || pageIndex < pageCount - 1;\n  var gotoPage = React.useCallback(function (updater) {\n    if (process.env.NODE_ENV === 'development' && debug) console.info('gotoPage');\n    return setState(function (old) {\n      var newPageIndex = typeof updater === 'function' ? updater(old.pageIndex) : updater;\n\n      if (newPageIndex < 0 || newPageIndex > pageCount - 1) {\n        return old;\n      }\n\n      return _objectSpread2({}, old, {\n        pageIndex: newPageIndex\n      });\n    }, actions.pageChange);\n  }, [debug, pageCount, setState]);\n  var previousPage = React.useCallback(function () {\n    return gotoPage(function (old) {\n      return old - 1;\n    });\n  }, [gotoPage]);\n  var nextPage = React.useCallback(function () {\n    return gotoPage(function (old) {\n      return old + 1;\n    });\n  }, [gotoPage]);\n  var setPageSize = React.useCallback(function (pageSize) {\n    setState(function (old) {\n      var topRowIndex = old.pageSize * old.pageIndex;\n      var pageIndex = Math.floor(topRowIndex / pageSize);\n      return _objectSpread2({}, old, {\n        pageIndex: pageIndex,\n        pageSize: pageSize\n      });\n    }, actions.pageSizeChange);\n  }, [setState]);\n  return _objectSpread2({}, instance, {\n    pageOptions: pageOptions,\n    pageCount: pageCount,\n    page: page,\n    canPreviousPage: canPreviousPage,\n    canNextPage: canNextPage,\n    gotoPage: gotoPage,\n    previousPage: previousPage,\n    nextPage: nextPage,\n    setPageSize: setPageSize,\n    pageIndex: pageIndex,\n    pageSize: pageSize\n  });\n}\n\ndefaultState.selectedRowPaths = [];\naddActions('toggleRowSelected', 'toggleRowSelectedAll');\n\nvar useRowSelect = function useRowSelect(hooks) {\n  hooks.getToggleRowSelectedProps = [];\n  hooks.getToggleAllRowsSelectedProps = [];\n  hooks.useRows.push(useRows);\n  hooks.useMain.push(useMain$5);\n};\n\nuseRowSelect.pluginName = 'useRowSelect';\n\nfunction useRows(rows, instance) {\n  var selectedRowPaths = instance.state.selectedRowPaths;\n  instance.selectedFlatRows = React.useMemo(function () {\n    var selectedFlatRows = [];\n    rows.forEach(function (row) {\n      if (row.isAggregated) {\n        var subRowPaths = row.subRows.map(function (row) {\n          return row.path;\n        });\n        row.isSelected = subRowPaths.every(function (path) {\n          return selectedRowPaths.includes(path.join('.'));\n        });\n      } else {\n        row.isSelected = selectedRowPaths.includes(row.path.join('.'));\n      }\n\n      if (row.isSelected) {\n        selectedFlatRows.push(row);\n      }\n    });\n    return selectedFlatRows;\n  }, [rows, selectedRowPaths]);\n  return rows;\n}\n\nvar defaultGetResetSelectedRowPathsDeps = function defaultGetResetSelectedRowPathsDeps(_ref) {\n  var rows = _ref.rows;\n  return [rows];\n};\n\nfunction useMain$5(instance) {\n  var hooks = instance.hooks,\n      _instance$manualRowSe = instance.manualRowSelectedKey,\n      manualRowSelectedKey = _instance$manualRowSe === void 0 ? 'isSelected' : _instance$manualRowSe,\n      plugins = instance.plugins,\n      flatRows = instance.flatRows,\n      _instance$getResetSel = instance.getResetSelectedRowPathsDeps,\n      getResetSelectedRowPathsDeps = _instance$getResetSel === void 0 ? defaultGetResetSelectedRowPathsDeps : _instance$getResetSel,\n      selectedRowPaths = instance.state.selectedRowPaths,\n      setState = instance.setState;\n  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy'], 'useRowSelect', []);\n  var flatRowPaths = flatRows.map(function (d) {\n    return d.path.join('.');\n  });\n  var isAllRowsSelected = !!flatRowPaths.length && !!selectedRowPaths.length;\n\n  if (isAllRowsSelected) {\n    if (flatRowPaths.some(function (d) {\n      return !selectedRowPaths.includes(d);\n    })) {\n      isAllRowsSelected = false;\n    }\n  } // Bypass any effects from firing when this changes\n\n\n  var isMountedRef = React.useRef();\n  safeUseLayoutEffect(function () {\n    if (isMountedRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          selectedRowPaths: []\n        });\n      }, actions.pageChange);\n    }\n\n    isMountedRef.current = true;\n  }, [setState].concat(_toConsumableArray(getResetSelectedRowPathsDeps ? getResetSelectedRowPathsDeps(instance) : [])));\n\n  var toggleRowSelectedAll = function toggleRowSelectedAll(set) {\n    setState(function (old) {\n      var selectAll = typeof set !== 'undefined' ? set : !isAllRowsSelected;\n      return _objectSpread2({}, old, {\n        selectedRowPaths: selectAll ? flatRowPaths : []\n      });\n    }, actions.toggleRowSelectedAll);\n  };\n\n  var updateParentRow = function updateParentRow(selectedRowPaths, path) {\n    var parentPath = path.slice(0, path.length - 1);\n    var parentKey = parentPath.join('.');\n    var selected = flatRowPaths.filter(function (rowPath) {\n      var path = rowPath;\n      return path !== parentKey && path.startsWith(parentKey) && !selectedRowPaths.has(path);\n    }).length === 0;\n\n    if (selected) {\n      selectedRowPaths.add(parentKey);\n    } else {\n      selectedRowPaths.delete(parentKey);\n    }\n\n    if (parentPath.length > 1) updateParentRow(selectedRowPaths, parentPath);\n  };\n\n  var toggleRowSelected = function toggleRowSelected(path, set) {\n    var key = path.join('.');\n    var childRowPrefixKey = [key, '.'].join('');\n    return setState(function (old) {\n      // Join the paths of deep rows\n      // to make a key, then manage all of the keys\n      // in a flat object\n      var exists = old.selectedRowPaths.includes(key);\n      var shouldExist = typeof set !== 'undefined' ? set : !exists;\n      var newSelectedRows = new Set(old.selectedRowPaths);\n\n      if (!exists && shouldExist) {\n        flatRowPaths.forEach(function (rowPath) {\n          if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {\n            newSelectedRows.add(rowPath);\n          }\n        });\n      } else if (exists && !shouldExist) {\n        flatRowPaths.forEach(function (rowPath) {\n          if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {\n            newSelectedRows.delete(rowPath);\n          }\n        });\n      } else {\n        return old;\n      } // If the row is a subRow update\n      // its parent row to reflect changes\n\n\n      if (path.length > 1) updateParentRow(newSelectedRows, path);\n      return _objectSpread2({}, old, {\n        selectedRowPaths: _toConsumableArray(newSelectedRows.values())\n      });\n    }, actions.toggleRowSelected);\n  };\n\n  var getToggleAllRowsSelectedProps = function getToggleAllRowsSelectedProps(props) {\n    return mergeProps({\n      onChange: function onChange(e) {\n        toggleRowSelectedAll(e.target.checked);\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      checked: isAllRowsSelected,\n      title: 'Toggle All Rows Selected'\n    }, applyPropHooks(instance.hooks.getToggleAllRowsSelectedProps, instance), props);\n  };\n\n  hooks.prepareRow.push(function (row) {\n    // Aggregate rows have entirely different select logic\n    if (row.isAggregated) {\n      var subRowPaths = row.subRows.map(function (row) {\n        return row.path;\n      });\n\n      row.toggleRowSelected = function (set) {\n        set = typeof set !== 'undefined' ? set : !row.isSelected;\n        subRowPaths.forEach(function (path) {\n          toggleRowSelected(path, set);\n        });\n      };\n\n      row.getToggleRowSelectedProps = function (props) {\n        var checked = false;\n\n        if (row.original && row.original[manualRowSelectedKey]) {\n          checked = true;\n        } else {\n          checked = row.isSelected;\n        }\n\n        return mergeProps({\n          onChange: function onChange(e) {\n            row.toggleRowSelected(e.target.checked);\n          },\n          style: {\n            cursor: 'pointer'\n          },\n          checked: checked,\n          title: 'Toggle Row Selected'\n        }, applyPropHooks(instance.hooks.getToggleRowSelectedProps, row, instance), props);\n      };\n    } else {\n      row.toggleRowSelected = function (set) {\n        return toggleRowSelected(row.path, set);\n      };\n\n      row.getToggleRowSelectedProps = function (props) {\n        var checked = false;\n\n        if (row.original && row.original[manualRowSelectedKey]) {\n          checked = true;\n        } else {\n          checked = row.isSelected;\n        }\n\n        return mergeProps({\n          onChange: function onChange(e) {\n            row.toggleRowSelected(e.target.checked);\n          },\n          style: {\n            cursor: 'pointer'\n          },\n          checked: checked,\n          title: 'Toggle Row Selected'\n        }, applyPropHooks(instance.hooks.getToggleRowSelectedProps, row, instance), props);\n      };\n    }\n\n    return row;\n  });\n  return _objectSpread2({}, instance, {\n    toggleRowSelected: toggleRowSelected,\n    toggleRowSelectedAll: toggleRowSelectedAll,\n    getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps,\n    isAllRowsSelected: isAllRowsSelected\n  });\n}\n\ndefaultState.rowState = {};\naddActions('setRowState', 'setCellState');\n\nvar useRowState = function useRowState(hooks) {\n  hooks.useMain.push(useMain$6);\n};\n\nuseRowState.pluginName = 'useRowState';\n\nfunction useMain$6(instance) {\n  var hooks = instance.hooks,\n      rows = instance.rows,\n      initialRowStateAccessor = instance.initialRowStateAccessor,\n      rowState = instance.state.rowState,\n      setState = instance.setState;\n  var setRowState = React.useCallback(function (path, updater) {\n    var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : actions.setRowState;\n    var pathKey = path.join('.');\n    return setState(function (old) {\n      return _objectSpread2({}, old, {\n        rowState: _objectSpread2({}, old.rowState, _defineProperty({}, pathKey, typeof updater === 'function' ? updater(old.rowState[pathKey]) : updater))\n      });\n    }, action);\n  }, [setState]);\n  var setCellState = React.useCallback(function (rowPath, columnID, updater) {\n    return setRowState(rowPath, function (old) {\n      return _objectSpread2({}, old, {\n        cellState: _objectSpread2({}, old.cellState, _defineProperty({}, columnID, typeof updater === 'function' ? updater(old.cellState[columnID]) : updater))\n      });\n    }, actions.setCellState);\n  }, [setRowState]);\n  var rowsMountedRef = React.useRef(); // When data changes, reset row and cell state\n\n  React.useEffect(function () {\n    if (rowsMountedRef.current) {\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          rowState: {}\n        });\n      }, actions.setRowState);\n    }\n\n    rowsMountedRef.current = true;\n  }, [rows, setState]);\n  hooks.prepareRow.push(function (row) {\n    var pathKey = row.path.join('.');\n\n    if (row.original) {\n      row.state = (typeof rowState[pathKey] !== 'undefined' ? rowState[pathKey] : initialRowStateAccessor && initialRowStateAccessor(row)) || {};\n\n      row.setState = function (updater) {\n        return setRowState(row.path, updater);\n      };\n\n      row.cells.forEach(function (cell) {\n        cell.state = row.state.cellState || {};\n\n        cell.setState = function (updater) {\n          return setCellState(row.path, cell.column.id, updater);\n        };\n      });\n    }\n\n    return row;\n  });\n  return _objectSpread2({}, instance, {\n    setRowState: setRowState,\n    setCellState: setCellState\n  });\n}\n\ndefaultState.columnOrder = [];\naddActions('setColumnOrder');\n\nvar useColumnOrder = function useColumnOrder(hooks) {\n  hooks.columnsBeforeHeaderGroupsDeps.push(function (deps, instance) {\n    return [].concat(_toConsumableArray(deps), [instance.state.columnOrder]);\n  });\n  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups$1);\n  hooks.useMain.push(useMain$7);\n};\n\nuseColumnOrder.pluginName = 'useColumnOrder';\n\nfunction columnsBeforeHeaderGroups$1(columns, instance) {\n  var columnOrder = instance.state.columnOrder; // If there is no order, return the normal columns\n\n  if (!columnOrder || !columnOrder.length) {\n    return columns;\n  }\n\n  var columnOrderCopy = _toConsumableArray(columnOrder); // If there is an order, make a copy of the columns\n\n\n  var columnsCopy = _toConsumableArray(columns); // And make a new ordered array of the columns\n\n\n  var columnsInOrder = []; // Loop over the columns and place them in order into the new array\n\n  var _loop = function _loop() {\n    var targetColumnID = columnOrderCopy.shift();\n    var foundIndex = columnsCopy.findIndex(function (d) {\n      return d.id === targetColumnID;\n    });\n\n    if (foundIndex > -1) {\n      columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);\n    }\n  };\n\n  while (columnsCopy.length && columnOrderCopy.length) {\n    _loop();\n  } // If there are any columns left, add them to the end\n\n\n  return [].concat(columnsInOrder, _toConsumableArray(columnsCopy));\n}\n\nfunction useMain$7(instance) {\n  var setState = instance.setState;\n  var setColumnOrder = React.useCallback(function (updater) {\n    return setState(function (old) {\n      return _objectSpread2({}, old, {\n        columnOrder: typeof updater === 'function' ? updater(old.columnOrder) : updater\n      });\n    }, actions.setColumnOrder);\n  }, [setState]);\n  return _objectSpread2({}, instance, {\n    setColumnOrder: setColumnOrder\n  });\n}\n\ndefaultState.columnResizing = {\n  columnWidths: {}\n};\ndefaultColumn.canResize = true;\n\nvar useResizeColumns = function useResizeColumns(hooks) {\n  hooks.useBeforeDimensions.push(useBeforeDimensions);\n};\n\nuseResizeColumns.pluginName = 'useResizeColumns';\n\nvar useBeforeDimensions = function useBeforeDimensions(instance) {\n  instance.hooks.getResizerProps = [];\n  var flatHeaders = instance.flatHeaders,\n      disableResizing = instance.disableResizing,\n      getHeaderProps = instance.hooks.getHeaderProps,\n      columnResizing = instance.state.columnResizing,\n      setState = instance.setState;\n  getHeaderProps.push(function () {\n    return {\n      style: {\n        position: 'relative'\n      }\n    };\n  });\n\n  var _onMouseDown = function onMouseDown(e, header) {\n    var headersToResize = getLeafHeaders(header);\n    var startWidths = headersToResize.map(function (header) {\n      return header.totalWidth;\n    });\n    var startX = e.clientX;\n\n    var onMouseMove = function onMouseMove(e) {\n      var currentX = e.clientX;\n      var deltaX = currentX - startX;\n      var percentageDeltaX = deltaX / headersToResize.length;\n      var newColumnWidths = {};\n      headersToResize.forEach(function (header, index) {\n        newColumnWidths[header.id] = Math.max(startWidths[index] + percentageDeltaX, 0);\n      });\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          columnResizing: _objectSpread2({}, old.columnResizing, {\n            columnWidths: _objectSpread2({}, old.columnResizing.columnWidths, {}, newColumnWidths)\n          })\n        });\n      });\n    };\n\n    var onMouseUp = function onMouseUp(e) {\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n      setState(function (old) {\n        return _objectSpread2({}, old, {\n          columnResizing: _objectSpread2({}, old.columnResizing, {\n            startX: null,\n            isResizingColumn: null\n          })\n        });\n      });\n    };\n\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n    setState(function (old) {\n      return _objectSpread2({}, old, {\n        columnResizing: _objectSpread2({}, old.columnResizing, {\n          startX: startX,\n          isResizingColumn: header.id\n        })\n      });\n    });\n  };\n\n  flatHeaders.forEach(function (header) {\n    var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);\n    header.canResize = canResize;\n    header.width = columnResizing.columnWidths[header.id] || header.width;\n    header.isResizing = columnResizing.isResizingColumn === header.id;\n\n    if (canResize) {\n      header.getResizerProps = function (userProps) {\n        return mergeProps({\n          onMouseDown: function onMouseDown(e) {\n            return e.persist() || _onMouseDown(e, header);\n          },\n          style: {\n            cursor: 'ew-resize'\n          },\n          draggable: false\n        }, applyPropHooks(instance.hooks.getResizerProps, header, instance), userProps);\n      };\n    }\n  });\n  return instance;\n};\n\nfunction getLeafHeaders(header) {\n  var leafHeaders = [];\n\n  var recurseHeader = function recurseHeader(header) {\n    if (header.columns && header.columns.length) {\n      header.columns.map(recurseHeader);\n    }\n\n    leafHeaders.push(header);\n  };\n\n  recurseHeader(header);\n  return leafHeaders;\n}\n\nvar useAbsoluteLayout = function useAbsoluteLayout(hooks) {\n  hooks.useMain.push(useMain$8);\n};\n\nuseAbsoluteLayout.pluginName = 'useAbsoluteLayout';\n\nvar useMain$8 = function useMain(instance) {\n  var totalColumnsWidth = instance.totalColumnsWidth,\n      _instance$hooks = instance.hooks,\n      getRowProps = _instance$hooks.getRowProps,\n      getTableBodyProps = _instance$hooks.getTableBodyProps,\n      getHeaderGroupProps = _instance$hooks.getHeaderGroupProps,\n      getHeaderProps = _instance$hooks.getHeaderProps,\n      getCellProps = _instance$hooks.getCellProps;\n  var rowStyles = {\n    style: {\n      position: 'relative',\n      width: \"\".concat(totalColumnsWidth, \"px\")\n    }\n  };\n  getTableBodyProps.push(function () {\n    return rowStyles;\n  });\n  getRowProps.push(function () {\n    return rowStyles;\n  });\n  getHeaderGroupProps.push(function () {\n    return rowStyles;\n  }); // Calculating column/cells widths\n\n  var cellStyles = {\n    position: 'absolute',\n    top: 0\n  };\n  getHeaderProps.push(function (header) {\n    return {\n      style: _objectSpread2({}, cellStyles, {\n        left: \"\".concat(header.totalLeft, \"px\"),\n        width: \"\".concat(header.totalWidth, \"px\")\n      })\n    };\n  });\n  getCellProps.push(function (cell) {\n    return {\n      style: _objectSpread2({}, cellStyles, {\n        left: \"\".concat(cell.column.totalLeft, \"px\"),\n        width: \"\".concat(cell.column.totalWidth, \"px\")\n      })\n    };\n  });\n  return instance;\n};\n\nvar useBlockLayout = function useBlockLayout(hooks) {\n  hooks.useMain.push(useMain$9);\n};\n\nuseBlockLayout.pluginName = 'useBlockLayout';\n\nvar useMain$9 = function useMain(instance) {\n  var totalColumnsWidth = instance.totalColumnsWidth,\n      _instance$hooks = instance.hooks,\n      getRowProps = _instance$hooks.getRowProps,\n      getHeaderGroupProps = _instance$hooks.getHeaderGroupProps,\n      getHeaderProps = _instance$hooks.getHeaderProps,\n      getCellProps = _instance$hooks.getCellProps;\n  var rowStyles = {\n    style: {\n      display: 'flex',\n      width: \"\".concat(totalColumnsWidth, \"px\")\n    }\n  };\n  getRowProps.push(function () {\n    return rowStyles;\n  });\n  getHeaderGroupProps.push(function () {\n    return rowStyles;\n  });\n  var cellStyles = {\n    display: 'inline-block',\n    boxSizing: 'border-box'\n  };\n  getHeaderProps.push(function (header) {\n    return {\n      style: _objectSpread2({}, cellStyles, {\n        width: \"\".concat(header.totalWidth, \"px\")\n      })\n    };\n  });\n  getCellProps.push(function (cell) {\n    return {\n      style: _objectSpread2({}, cellStyles, {\n        width: \"\".concat(cell.column.totalWidth, \"px\")\n      })\n    };\n  });\n  return instance;\n};\n\nexport { actions, addActions, defaultColumn, defaultState, useAbsoluteLayout, useBlockLayout, useColumnOrder, useExpanded, useFilters, useGroupBy, usePagination, useResizeColumns, useRowSelect, useRowState, useSortBy, useTable, utils };","map":{"version":3,"mappings":"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","names":["defaultColumn","Cell","cell","value","String","show","width","minWidth","maxWidth","Number","MAX_SAFE_INTEGER","safeUseLayoutEffect","window","process","env","NODE_ENV","React","useLayoutEffect","useEffect","findMaxDepth","columns","depth","reduce","prev","curr","Math","max","decorateColumn","column","userDefaultColumn","parent","index","id","accessor","Header","accessorPath","split","getBy","row","console","error","Error","decorateColumnTree","map","columnIndex","makeHeaderGroups","flatColumns","headerGroups","buildGroup","headerGroup","headers","parentColumns","hasParents","some","col","forEach","isFirst","length","latestParentColumn","reverse","similarParentColumns","filter","d","originalID","push","join","placeholderColumn","placeholderOf","includes","totalHeaderCount","sum","header","determineHeaderVisibility","instance","handleColumn","parentVisible","isVisible","totalVisibleHeaderCount","subColumn","subHeader","obj","path","def","pathObj","makePathArray","val","cursor","pathPart","e","defaultOrderByFn","arr","funcs","dirs","_toConsumableArray","sort","rowA","rowB","i","sortFn","desc","sortInt","getFirstDefined","args","arguments","defaultGroupByFn","rows","columnID","resKey","values","Array","isArray","getElementDimensions","element","rect","getBoundingClientRect","style","getComputedStyle","margins","left","parseInt","marginLeft","right","marginRight","padding","paddingLeft","paddingRight","ceil","outerWidth","scrollWidth","flexRender","Comp","props","isReactComponent","isClassComponent","component","proto","Object","getPrototypeOf","prototype","isFunctionComponent","mergeProps","groups","className","rest","Boolean","applyHooks","hooks","initial","next","nextValue","applyPropHooks","warnUnknownProps","keys","JSON","stringify","isFunction","a","flattenBy","childKey","recurse","ensurePluginOrder","plugins","befores","pluginName","afters","pluginIndex","findIndex","plugin","beforeIndex","before","afterIndex","after","expandRows","_ref3","manualExpandedKey","expanded","expandSubRows","expandedRows","handleRow","key","isExpanded","original","canExpand","subRows","flattenDeep","replace","newArr","renderErr","defaultState","defaultInitialState","defaultColumnInstance","defaultReducer","old","newState","defaultGetSubRows","defaultGetRowID","useTable","data","userColumns","initialState","userState","state","getSubRows","getRowID","reducer","debug","useState","originalState","originalSetState","useMemo","setState","useCallback","updater","type","instanceRef","useRef","assign","current","columnsBeforeHeaderGroups","columnsBeforeHeaderGroupsDeps","useBeforeDimensions","useMain","useRows","prepareRow","getTableProps","getTableBodyProps","getRowProps","getHeaderGroupProps","getHeaderProps","getCellProps","time","timeEnd","newColumns","flatRows","accessRow","originalRow","parentPath","rowID","cells","unpreparedAccessWarning","undefined","accessedData","flatHeaders","all","calculateDimensions","render","userProps","colSpan","columnPathStr","totalColumnsWidth","calculateHeaderWidths","sumTotalWidth","subHeaders","totalLeft","totalWidth","min","actions","addActions","acts","action","useExpanded","getExpandedToggleProps","defaultGetResetExpandedDeps","paginateExpandedRows","getResetExpandedDeps","isMountedRef","pageChange","toggleExpandedByPath","set","exists","shouldExist","newExpanded","Set","add","delete","toggleExpanded","onClick","persist","title","info","expandedDepth","findExpandedDepth","maxDepth","text","filterValue","rowValue","toLowerCase","autoRemove","exactText","exactTextCase","includesAll","every","exact","equals","between","Infinity","temp","filters","useFilters","userFilterTypes","filterTypes","manualFilters","defaultCanFilter","disableFilters","getResetFiltersDeps","preFilteredRows","preFilteredFlatRows","setFilter","find","filterMethod","getFilterMethod","newFilter","shouldAutoRemove","remove","newFilters","setAllFilters","columnDefaultCanFilter","columnDisableFilters","canFilter","filteredRows","filteredFlatRows","filterRows","entries","filteredSoFar","warn","nonFilteredColumns","average","round","median","uniqueCount","size","count","groupBy","useGroupBy","deps","groupByColumns","g","nonGroupByColumns","groupByBoundaryColumnIndex","groupByBoundary","slice","groupByFn","manualGroupBy","defaultCanGroupBy","disableGroupBy","aggregations","userAggregations","defaultColumnGroupBy","defaultGroupBy","columnDisableGroupBy","isGrouped","groupedIndex","indexOf","canGroupBy","toggleGroupBy","Aggregated","toggle","resolvedToggle","getGroupByToggleProps","groupByID","isRepeatedValue","isAggregated","groupedRows","aggregateRowsToValues","isSourceRows","columnValues","aggregator","aggregate","aggregateFn","groupRecursively","groupByVal","preGroupedRows","reSplitAlphaNumeric","alphanumeric","getRowValueByColumnID","b","toString","aa","shift","bb","an","bn","combo","isNaN","datetime","getTime","compareBasic","basic","sortBy","sortType","sortDescFirst","useSortBy","orderByFn","userSortTypes","sortTypes","manualSorting","defaultCanSort","disableSortBy","disableSortRemove","disableMultiRemove","disableMultiSort","isMultiSortEvent","shiftKey","maxMultiSortColCount","getResetSortByDeps","getSortByToggleProps","toggleSortBy","multi","existingSortBy","existingIndex","hasDescDefined","newSortBy","splice","sortByChange","defaultColumnCanSort","canSort","columnDisableSortBy","clearSorting","columnSort","isSorted","sortedIndex","isSortedDesc","sortedRows","availableSortBy","sortData","sortedData","sortMethod","sortInverted","preSortedRows","pageSize","pageIndex","usePagination","defaultGetResetPageDeps","manualPagination","getResetPageDeps","userPageCount","pageCount","pageOptions","page","pageStart","pageEnd","canPreviousPage","canNextPage","gotoPage","newPageIndex","previousPage","nextPage","setPageSize","topRowIndex","floor","pageSizeChange","selectedRowPaths","useRowSelect","getToggleRowSelectedProps","getToggleAllRowsSelectedProps","selectedFlatRows","subRowPaths","isSelected","defaultGetResetSelectedRowPathsDeps","manualRowSelectedKey","getResetSelectedRowPathsDeps","flatRowPaths","isAllRowsSelected","toggleRowSelectedAll","selectAll","updateParentRow","parentKey","selected","rowPath","startsWith","has","toggleRowSelected","childRowPrefixKey","newSelectedRows","onChange","target","checked","rowState","useRowState","initialRowStateAccessor","setRowState","pathKey","setCellState","cellState","rowsMountedRef","columnOrder","useColumnOrder","columnOrderCopy","columnsCopy","columnsInOrder","targetColumnID","foundIndex","setColumnOrder","columnResizing","columnWidths","canResize","useResizeColumns","getResizerProps","disableResizing","position","onMouseDown","headersToResize","getLeafHeaders","startWidths","startX","clientX","onMouseMove","currentX","deltaX","percentageDeltaX","newColumnWidths","onMouseUp","document","removeEventListener","isResizingColumn","addEventListener","isResizing","draggable","leafHeaders","recurseHeader","useAbsoluteLayout","rowStyles","cellStyles","top","useBlockLayout","display","boxSizing"],"sources":["/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/utils.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/hooks/useTable.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/actions.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useExpanded.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/filterTypes.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useFilters.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/aggregations.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useGroupBy.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/sortTypes.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useSortBy.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/usePagination.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useRowSelect.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useRowState.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useColumnOrder.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useResizeColumns.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useAbsoluteLayout.js","/home/llanard/projects/logrocket-smart-table/node_modules/react-table/src/plugin-hooks/useBlockLayout.js"],"sourcesContent":["import React from 'react'\n\nexport const defaultColumn = {\n  Cell: ({ cell: { value = '' } }) => String(value),\n  show: true,\n  width: 150,\n  minWidth: 0,\n  maxWidth: Number.MAX_SAFE_INTEGER,\n}\n\n// SSR has issues with useLayoutEffect still, so use useEffect during SSR\nexport const safeUseLayoutEffect =\n  typeof window !== 'undefined' && process.env.NODE_ENV === 'production'\n    ? React.useLayoutEffect\n    : React.useEffect\n\n// Find the depth of the columns\nexport function findMaxDepth(columns, depth = 0) {\n  return columns.reduce((prev, curr) => {\n    if (curr.columns) {\n      return Math.max(prev, findMaxDepth(curr.columns, depth + 1))\n    }\n    return depth\n  }, 0)\n}\n\nexport function decorateColumn(\n  column,\n  userDefaultColumn,\n  parent,\n  depth,\n  index\n) {\n  // Apply the userDefaultColumn\n  column = { ...defaultColumn, ...userDefaultColumn, ...column }\n\n  // First check for string accessor\n  let { id, accessor, Header } = column\n\n  if (typeof accessor === 'string') {\n    id = id || accessor\n    const accessorPath = accessor.split('.')\n    accessor = row => getBy(row, accessorPath)\n  }\n\n  if (!id && typeof Header === 'string' && Header) {\n    id = Header\n  }\n\n  if (!id && column.columns) {\n    console.error(column)\n    throw new Error('A column ID (or unique \"Header\" value) is required!')\n  }\n\n  if (!id) {\n    console.error(column)\n    throw new Error('A column ID (or string accessor) is required!')\n  }\n\n  column = {\n    // Make sure there is a fallback header, just in case\n    Header: () => <>&nbsp;</>,\n    ...column,\n    // Materialize and override this stuff\n    id,\n    accessor,\n    parent,\n    depth,\n    index,\n  }\n\n  return column\n}\n\n// Build the visible columns, headers and flat column list\nexport function decorateColumnTree(columns, defaultColumn, parent, depth = 0) {\n  return columns.map((column, columnIndex) => {\n    column = decorateColumn(column, defaultColumn, parent, depth, columnIndex)\n    if (column.columns) {\n      column.columns = decorateColumnTree(\n        column.columns,\n        defaultColumn,\n        column,\n        depth + 1\n      )\n    }\n    return column\n  })\n}\n\n// Build the header groups from the bottom up\nexport function makeHeaderGroups(flatColumns, defaultColumn) {\n  const headerGroups = []\n\n  // Build each header group from the bottom up\n  const buildGroup = (columns, depth) => {\n    const headerGroup = {\n      headers: [],\n    }\n\n    const parentColumns = []\n\n    // Do any of these columns have parents?\n    const hasParents = columns.some(col => col.parent)\n\n    columns.forEach(column => {\n      // Are we the first column in this group?\n      const isFirst = !parentColumns.length\n\n      // What is the latest (last) parent column?\n      let latestParentColumn = [...parentColumns].reverse()[0]\n\n      // If the column has a parent, add it if necessary\n      if (column.parent) {\n        const similarParentColumns = parentColumns.filter(\n          d => d.originalID === column.parent.id\n        )\n        if (isFirst || latestParentColumn.originalID !== column.parent.id) {\n          parentColumns.push({\n            ...column.parent,\n            originalID: column.parent.id,\n            id: [column.parent.id, similarParentColumns.length].join('_'),\n          })\n        }\n      } else if (hasParents) {\n        // If other columns have parents, we'll need to add a place holder if necessary\n        const originalID = [column.id, 'placeholder'].join('_')\n        const similarParentColumns = parentColumns.filter(\n          d => d.originalID === originalID\n        )\n        const placeholderColumn = decorateColumn(\n          {\n            originalID,\n            id: [column.id, 'placeholder', similarParentColumns.length].join(\n              '_'\n            ),\n            placeholderOf: column,\n          },\n          defaultColumn\n        )\n        if (\n          isFirst ||\n          latestParentColumn.originalID !== placeholderColumn.originalID\n        ) {\n          parentColumns.push(placeholderColumn)\n        }\n      }\n\n      // Establish the new headers[] relationship on the parent\n      if (column.parent || hasParents) {\n        latestParentColumn = [...parentColumns].reverse()[0]\n        latestParentColumn.headers = latestParentColumn.headers || []\n        if (!latestParentColumn.headers.includes(column)) {\n          latestParentColumn.headers.push(column)\n        }\n      }\n\n      column.totalHeaderCount = column.headers\n        ? column.headers.reduce(\n            (sum, header) => sum + header.totalHeaderCount,\n            0\n          )\n        : 1 // Leaf node columns take up at least one count\n      headerGroup.headers.push(column)\n    })\n\n    headerGroups.push(headerGroup)\n\n    if (parentColumns.length) {\n      buildGroup(parentColumns, depth + 1)\n    }\n  }\n\n  buildGroup(flatColumns, 0)\n\n  return headerGroups.reverse()\n}\n\nexport function determineHeaderVisibility(instance) {\n  const { headers } = instance\n\n  const handleColumn = (column, parentVisible) => {\n    column.isVisible = parentVisible\n      ? typeof column.show === 'function'\n        ? column.show(instance)\n        : !!column.show\n      : false\n\n    let totalVisibleHeaderCount = 0\n\n    if (column.headers && column.headers.length) {\n      column.headers.forEach(\n        subColumn =>\n          (totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible))\n      )\n    } else {\n      totalVisibleHeaderCount = column.isVisible ? 1 : 0\n    }\n\n    column.totalVisibleHeaderCount = totalVisibleHeaderCount\n\n    return totalVisibleHeaderCount\n  }\n\n  let totalVisibleHeaderCount = 0\n\n  headers.forEach(\n    subHeader => (totalVisibleHeaderCount += handleColumn(subHeader, true))\n  )\n}\n\nexport function getBy(obj, path, def) {\n  if (!path) {\n    return obj\n  }\n  const pathObj = makePathArray(path)\n  let val\n  try {\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj)\n  } catch (e) {\n    // continue regardless of error\n  }\n  return typeof val !== 'undefined' ? val : def\n}\n\nexport function defaultOrderByFn(arr, funcs, dirs) {\n  return [...arr].sort((rowA, rowB) => {\n    for (let i = 0; i < funcs.length; i += 1) {\n      const sortFn = funcs[i]\n      const desc = dirs[i] === false || dirs[i] === 'desc'\n      const sortInt = sortFn(rowA, rowB)\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt\n      }\n    }\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index\n  })\n}\n\nexport function getFirstDefined(...args) {\n  for (let i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i]\n    }\n  }\n}\n\nexport function defaultGroupByFn(rows, columnID) {\n  return rows.reduce((prev, row, i) => {\n    // TODO: Might want to implement a key serializer here so\n    // irregular column values can still be grouped if needed?\n    const resKey = `${row.values[columnID]}`\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : []\n    prev[resKey].push(row)\n    return prev\n  }, {})\n}\n\nexport function getElementDimensions(element) {\n  const rect = element.getBoundingClientRect()\n  const style = window.getComputedStyle(element)\n  const margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight),\n  }\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight),\n  }\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(\n      rect.width + margins.left + margins.right + padding.left + padding.right\n    ),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth,\n  }\n}\n\nexport function flexRender(Comp, props) {\n  return isReactComponent(Comp) ? <Comp {...props} /> : Comp\n}\n\nfunction isClassComponent(component) {\n  return (\n    typeof component === 'function' &&\n    !!(() => {\n      let proto = Object.getPrototypeOf(component)\n      return proto.prototype && proto.prototype.isReactComponent\n    })()\n  )\n}\n\nfunction isFunctionComponent(component) {\n  return typeof component === 'function'\n}\n\nfunction isReactComponent(component) {\n  return isClassComponent(component) || isFunctionComponent(component)\n}\n\nexport const mergeProps = (...groups) => {\n  let props = {}\n\n  groups.forEach(({ style = {}, className, ...rest } = {}) => {\n    props = {\n      ...props,\n      ...rest,\n      style: {\n        ...(props.style || {}),\n        ...style,\n      },\n      className: [props.className, className].filter(Boolean).join(' '),\n    }\n  })\n\n  if (props.className === '') {\n    delete props.className\n  }\n\n  return props\n}\n\nexport const applyHooks = (hooks, initial, ...args) =>\n  hooks.reduce((prev, next) => {\n    const nextValue = next(prev, ...args)\n    if (typeof nextValue === 'undefined') {\n      throw new Error(\n        'React Table: A hook just returned undefined! This is not allowed.'\n      )\n    }\n    return nextValue\n  }, initial)\n\nexport const applyPropHooks = (hooks, ...args) =>\n  hooks.reduce((prev, next) => mergeProps(prev, next(...args)), {})\n\nexport const warnUnknownProps = props => {\n  if (Object.keys(props).length) {\n    throw new Error(\n      `Unknown options passed to useReactTable:\n\n${JSON.stringify(props, null, 2)}`\n    )\n  }\n}\n\nexport function sum(arr) {\n  return arr.reduce((prev, curr) => prev + curr, 0)\n}\n\nexport function isFunction(a) {\n  if (typeof a === 'function') {\n    return a\n  }\n}\n\nexport function flattenBy(columns, childKey) {\n  const flatColumns = []\n\n  const recurse = columns => {\n    columns.forEach(d => {\n      if (!d[childKey]) {\n        flatColumns.push(d)\n      } else {\n        recurse(d[childKey])\n      }\n    })\n  }\n\n  recurse(columns)\n\n  return flatColumns\n}\n\nexport function ensurePluginOrder(plugins, befores, pluginName, afters) {\n  const pluginIndex = plugins.findIndex(\n    plugin => plugin.pluginName === pluginName\n  )\n\n  if (pluginIndex === -1) {\n    throw new Error(`The plugin ${pluginName} was not found in the plugin list!\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\n\n  ${pluginName}.pluginName = '${pluginName}'\n`)\n  }\n\n  befores.forEach(before => {\n    const beforeIndex = plugins.findIndex(\n      plugin => plugin.pluginName === before\n    )\n    if (beforeIndex > -1 && beforeIndex > pluginIndex) {\n      throw new Error(\n        `React Table: The ${pluginName} plugin hook must be placed after the ${before} plugin hook!`\n      )\n    }\n  })\n\n  afters.forEach(after => {\n    const afterIndex = plugins.findIndex(plugin => plugin.pluginName === after)\n    if (afterIndex > -1 && afterIndex < pluginIndex) {\n      throw new Error(\n        `React Table: The ${pluginName} plugin hook must be placed before the ${after} plugin hook!`\n      )\n    }\n  })\n}\n\nexport function expandRows(\n  rows,\n  { manualExpandedKey, expanded, expandSubRows = true }\n) {\n  const expandedRows = []\n\n  const handleRow = row => {\n    const key = row.path.join('.')\n\n    row.isExpanded =\n      (row.original && row.original[manualExpandedKey]) ||\n      expanded.includes(key)\n\n    row.canExpand = row.subRows && !!row.subRows.length\n\n    expandedRows.push(row)\n\n    if (expandSubRows && row.subRows && row.subRows.length && row.isExpanded) {\n      row.subRows.forEach(handleRow)\n    }\n  }\n\n  rows.forEach(handleRow)\n\n  return expandedRows\n}\n\n//\n\nfunction makePathArray(obj) {\n  return (\n    flattenDeep(obj)\n      // remove all periods in parts\n      .map(d => String(d).replace('.', '_'))\n      // join parts using period\n      .join('.')\n      // replace brackets with periods\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      // split it back out on periods\n      .split('.')\n  )\n}\n\nfunction flattenDeep(arr, newArr = []) {\n  if (!Array.isArray(arr)) {\n    newArr.push(arr)\n  } else {\n    for (let i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr)\n    }\n  }\n  return newArr\n}\n","import React from 'react'\n\n//\nimport {\n  applyHooks,\n  applyPropHooks,\n  mergeProps,\n  flexRender,\n  decorateColumnTree,\n  makeHeaderGroups,\n  flattenBy,\n  determineHeaderVisibility,\n} from '../utils'\n\nconst renderErr =\n  'You must specify a valid render component. This could be \"column.Cell\", \"column.Header\", \"column.Filter\", \"column.Aggregated\" or any other custom renderer component.'\n\nexport const defaultState = {}\n\nconst defaultInitialState = {}\nconst defaultColumnInstance = {}\nconst defaultReducer = (old, newState) => newState\nconst defaultGetSubRows = (row, index) => row.subRows || []\nconst defaultGetRowID = (row, index) => index\n\nexport const useTable = (props, ...plugins) => {\n  // Destructure props\n  let {\n    data,\n    columns: userColumns,\n    initialState = defaultInitialState,\n    state: userState,\n    defaultColumn = defaultColumnInstance,\n    getSubRows = defaultGetSubRows,\n    getRowID = defaultGetRowID,\n    reducer = defaultReducer,\n    debug,\n  } = props\n\n  debug = process.env.NODE_ENV === 'production' ? false : debug\n\n  // But use the users table state if provided\n  let [originalState, originalSetState] = React.useState({\n    ...defaultState,\n    ...initialState,\n  })\n\n  const state = React.useMemo(() => {\n    if (userState) {\n      const newState = {\n        ...originalState,\n      }\n      Object.keys(userState).forEach(key => {\n        newState[key] = userState[key]\n      })\n      return newState\n    }\n    return originalState\n  }, [originalState, userState])\n\n  const setState = React.useCallback(\n    (updater, type) => {\n      return originalSetState(old => {\n        const newState = typeof updater === 'function' ? updater(old) : updater\n        return reducer(old, newState, type)\n      })\n    },\n    [reducer]\n  )\n\n  // The table instance ref\n  let instanceRef = React.useRef({})\n\n  Object.assign(instanceRef.current, {\n    ...props,\n    data, // The raw data\n    state,\n    setState, // The resolved table state\n    plugins, // All resolved plugins\n    hooks: {\n      columnsBeforeHeaderGroups: [],\n      columnsBeforeHeaderGroupsDeps: [],\n      useBeforeDimensions: [],\n      useMain: [],\n      useRows: [],\n      prepareRow: [],\n      getTableProps: [],\n      getTableBodyProps: [],\n      getRowProps: [],\n      getHeaderGroupProps: [],\n      getHeaderProps: [],\n      getCellProps: [],\n    },\n  })\n\n  // Allow plugins to register hooks\n  if (process.env.NODE_ENV === 'development' && debug) console.time('plugins')\n\n  plugins.filter(Boolean).forEach(plugin => {\n    plugin(instanceRef.current.hooks)\n  })\n\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.timeEnd('plugins')\n\n  // Decorate All the columns\n  let columns = React.useMemo(\n    () => decorateColumnTree(userColumns, defaultColumn),\n    [defaultColumn, userColumns]\n  )\n\n  // Get the flat list of all columns and allow hooks to decorate\n  // those columns (and trigger this memoization via deps)\n  let flatColumns = React.useMemo(() => {\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.time('hooks.columnsBeforeHeaderGroups')\n\n    let newColumns = applyHooks(\n      instanceRef.current.hooks.columnsBeforeHeaderGroups,\n      flattenBy(columns, 'columns'),\n      instanceRef.current\n    )\n\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.timeEnd('hooks.columnsBeforeHeaderGroups')\n    return newColumns\n  }, [\n    columns,\n    debug,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    ...applyHooks(\n      instanceRef.current.hooks.columnsBeforeHeaderGroupsDeps,\n      [],\n      instanceRef.current\n    ),\n  ])\n\n  // Make the headerGroups\n  const headerGroups = React.useMemo(\n    () => makeHeaderGroups(flatColumns, defaultColumn),\n    [defaultColumn, flatColumns]\n  )\n\n  const headers = React.useMemo(() => headerGroups[0].headers, [headerGroups])\n\n  Object.assign(instanceRef.current, {\n    columns,\n    flatColumns,\n    headerGroups,\n    headers,\n  })\n\n  // Access the row model\n  const [rows, flatRows] = React.useMemo(() => {\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.time('getAccessedRows')\n\n    let flatRows = []\n\n    // Access the row's data\n    const accessRow = (originalRow, i, depth = 0, parentPath = []) => {\n      // Keep the original reference around\n      const original = originalRow\n\n      const rowID = getRowID(originalRow, i)\n\n      // Make the new path for the row\n      const path = [...parentPath, rowID]\n\n      const row = {\n        original,\n        index: i,\n        path, // used to create a key for each row even if not nested\n        depth,\n        cells: [{}], // This is a dummy cell\n      }\n\n      flatRows.push(row)\n\n      // Process any subRows\n      let subRows = getSubRows(originalRow, i)\n\n      if (subRows) {\n        row.subRows = subRows.map((d, i) => accessRow(d, i, depth + 1, path))\n      }\n\n      // Override common array functions (and the dummy cell's getCellProps function)\n      // to show an error if it is accessed without calling prepareRow\n      const unpreparedAccessWarning = () => {\n        throw new Error(\n          'React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.'\n        )\n      }\n      row.cells.map = unpreparedAccessWarning\n      row.cells.filter = unpreparedAccessWarning\n      row.cells.forEach = unpreparedAccessWarning\n      row.cells[0].getCellProps = unpreparedAccessWarning\n\n      // Create the cells and values\n      row.values = {}\n      flatColumns.forEach(column => {\n        row.values[column.id] = column.accessor\n          ? column.accessor(originalRow, i, { subRows, depth, data })\n          : undefined\n      })\n\n      return row\n    }\n\n    // Use the resolved data\n    const accessedData = data.map((d, i) => accessRow(d, i))\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.timeEnd('getAccessedRows')\n    return [accessedData, flatRows]\n  }, [debug, data, getRowID, getSubRows, flatColumns])\n\n  instanceRef.current.rows = rows\n  instanceRef.current.flatRows = flatRows\n\n  // Determine column visibility\n  determineHeaderVisibility(instanceRef.current)\n\n  // Provide a flat header list for utilities\n  instanceRef.current.flatHeaders = headerGroups.reduce(\n    (all, headerGroup) => [...all, ...headerGroup.headers],\n    []\n  )\n\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.time('hooks.useBeforeDimensions')\n  instanceRef.current = applyHooks(\n    instanceRef.current.hooks.useBeforeDimensions,\n    instanceRef.current\n  )\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.timeEnd('hooks.useBeforeDimensions')\n\n  calculateDimensions(instanceRef.current)\n\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.time('hooks.useMain')\n  instanceRef.current = applyHooks(\n    instanceRef.current.hooks.useMain,\n    instanceRef.current\n  )\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.timeEnd('hooks.useMain')\n\n  // Each materialized header needs to be assigned a render function and other\n  // prop getter properties here.\n  instanceRef.current.flatHeaders.forEach(column => {\n    // Give columns/headers rendering power\n    column.render = (type, userProps = {}) => {\n      const Comp = typeof type === 'string' ? column[type] : type\n\n      if (typeof Comp === 'undefined') {\n        throw new Error(renderErr)\n      }\n\n      return flexRender(Comp, {\n        ...instanceRef.current,\n        column,\n        ...userProps,\n      })\n    }\n\n    // Give columns/headers a default getHeaderProps\n    column.getHeaderProps = props =>\n      mergeProps(\n        {\n          key: ['header', column.id].join('_'),\n          colSpan: column.totalVisibleHeaderCount,\n        },\n        applyPropHooks(\n          instanceRef.current.hooks.getHeaderProps,\n          column,\n          instanceRef.current\n        ),\n        props\n      )\n  })\n\n  instanceRef.current.headerGroups.forEach((headerGroup, i) => {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter(header => {\n      const recurse = headers =>\n        headers.filter(header => {\n          if (header.headers) {\n            return recurse(header.headers)\n          }\n          return header.isVisible\n        }).length\n      if (header.headers) {\n        return recurse(header.headers)\n      }\n      return header.isVisible\n    })\n\n    // Give headerGroups getRowProps\n    if (headerGroup.headers.length) {\n      headerGroup.getHeaderGroupProps = (props = {}) =>\n        mergeProps(\n          {\n            key: [`header${i}`].join('_'),\n          },\n          applyPropHooks(\n            instanceRef.current.hooks.getHeaderGroupProps,\n            headerGroup,\n            instanceRef.current\n          ),\n          props\n        )\n\n      return true\n    }\n  })\n\n  // Run the rows (this could be a dangerous hook with a ton of data)\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.time('hooks.useRows')\n  instanceRef.current.rows = applyHooks(\n    instanceRef.current.hooks.useRows,\n    instanceRef.current.rows,\n    instanceRef.current\n  )\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.timeEnd('hooks.useRows')\n\n  // The prepareRow function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n\n  instanceRef.current.prepareRow = React.useCallback(row => {\n    row.getRowProps = props =>\n      mergeProps(\n        { key: ['row', ...row.path].join('_') },\n        applyPropHooks(\n          instanceRef.current.hooks.getRowProps,\n          row,\n          instanceRef.current\n        ),\n        props\n      )\n\n    // Build the visible cells for each row\n    row.cells = instanceRef.current.flatColumns\n      .filter(d => d.isVisible)\n      .map(column => {\n        const cell = {\n          column,\n          row,\n          value: row.values[column.id],\n        }\n\n        // Give each cell a getCellProps base\n        cell.getCellProps = props => {\n          const columnPathStr = [...row.path, column.id].join('_')\n          return mergeProps(\n            {\n              key: ['cell', columnPathStr].join('_'),\n            },\n            applyPropHooks(\n              instanceRef.current.hooks.getCellProps,\n              cell,\n              instanceRef.current\n            ),\n            props\n          )\n        }\n\n        // Give each cell a renderer function (supports multiple renderers)\n        cell.render = (type, userProps = {}) => {\n          const Comp = typeof type === 'string' ? column[type] : type\n\n          if (typeof Comp === 'undefined') {\n            throw new Error(renderErr)\n          }\n\n          return flexRender(Comp, {\n            ...instanceRef.current,\n            column,\n            row,\n            cell,\n            ...userProps,\n          })\n        }\n\n        return cell\n      })\n\n    // need to apply any row specific hooks (useExpanded requires this)\n    applyHooks(instanceRef.current.hooks.prepareRow, row, instanceRef.current)\n  }, [])\n\n  instanceRef.current.getTableProps = userProps =>\n    mergeProps(\n      applyPropHooks(\n        instanceRef.current.hooks.getTableProps,\n        instanceRef.current\n      ),\n      userProps\n    )\n\n  instanceRef.current.getTableBodyProps = userProps =>\n    mergeProps(\n      applyPropHooks(\n        instanceRef.current.hooks.getTableBodyProps,\n        instanceRef.current\n      ),\n      userProps\n    )\n\n  return instanceRef.current\n}\n\nfunction calculateDimensions(instance) {\n  const { headers } = instance\n\n  instance.totalColumnsWidth = calculateHeaderWidths(headers)\n}\n\nfunction calculateHeaderWidths(headers, left = 0) {\n  let sumTotalWidth = 0\n\n  headers.forEach(header => {\n    let { headers: subHeaders } = header\n\n    header.totalLeft = left\n\n    if (subHeaders && subHeaders.length) {\n      header.totalWidth = calculateHeaderWidths(subHeaders, left)\n    } else {\n      header.totalWidth = Math.min(\n        Math.max(header.minWidth, header.width),\n        header.maxWidth\n      )\n    }\n    if (header.isVisible) {\n      left += header.totalWidth\n      sumTotalWidth += header.totalWidth\n    }\n  })\n\n  return sumTotalWidth\n}\n","const actions = {}\nconst types = {}\n\nexport { actions, types }\n\nexport const addActions = (...acts) => {\n  acts.forEach(action => {\n    // Action values are formatted this way to discourage\n    // you (the dev) from interacting with them in any way\n    // other than importing `{ actions } from 'react-table'`\n    // and referencing an action via `actions[actionName]`\n    actions[action] = `React Table Action: ${action}`\n    types[actions[action]] = true\n  })\n}\n","import React from 'react'\n\nimport {\n  mergeProps,\n  applyPropHooks,\n  expandRows,\n  safeUseLayoutEffect,\n} from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.expanded = []\n\naddActions('toggleExpanded', 'useExpanded')\n\nexport const useExpanded = hooks => {\n  hooks.getExpandedToggleProps = []\n  hooks.useMain.push(useMain)\n}\n\nuseExpanded.pluginName = 'useExpanded'\n\nconst defaultGetResetExpandedDeps = instance => [instance.data]\n\nfunction useMain(instance) {\n  const {\n    debug,\n    rows,\n    manualExpandedKey = 'expanded',\n    paginateExpandedRows = true,\n    expandSubRows = true,\n    hooks,\n    state: { expanded },\n    setState,\n    getResetExpandedDeps = defaultGetResetExpandedDeps,\n  } = instance\n\n  // Bypass any effects from firing when this changes\n  const isMountedRef = React.useRef()\n  safeUseLayoutEffect(() => {\n    if (isMountedRef.current) {\n      setState(\n        old => ({\n          ...old,\n          expanded: [],\n        }),\n        actions.pageChange\n      )\n    }\n    isMountedRef.current = true\n  }, [\n    setState,\n    ...(getResetExpandedDeps ? getResetExpandedDeps(instance) : []),\n  ])\n\n  const toggleExpandedByPath = (path, set) => {\n    const key = path.join('.')\n\n    return setState(old => {\n      const exists = old.expanded.includes(key)\n      const shouldExist = typeof set !== 'undefined' ? set : !exists\n      let newExpanded = new Set(old.expanded)\n\n      if (!exists && shouldExist) {\n        newExpanded.add(key)\n      } else if (exists && !shouldExist) {\n        newExpanded.delete(key)\n      } else {\n        return old\n      }\n\n      return {\n        ...old,\n        expanded: [...newExpanded.values()],\n      }\n    }, actions.toggleExpanded)\n  }\n\n  hooks.prepareRow.push(row => {\n    row.toggleExpanded = set => toggleExpandedByPath(row.path, set)\n    row.getExpandedToggleProps = props => {\n      return mergeProps(\n        {\n          onClick: e => {\n            e.persist()\n            row.toggleExpanded()\n          },\n          style: {\n            cursor: 'pointer',\n          },\n          title: 'Toggle Expanded',\n        },\n        applyPropHooks(instance.hooks.getExpandedToggleProps, row, instance),\n        props\n      )\n    }\n    return row\n  })\n\n  const expandedRows = React.useMemo(() => {\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.info('getExpandedRows')\n\n    if (paginateExpandedRows) {\n      return expandRows(rows, { manualExpandedKey, expanded, expandSubRows })\n    }\n\n    return rows\n  }, [\n    debug,\n    paginateExpandedRows,\n    rows,\n    manualExpandedKey,\n    expanded,\n    expandSubRows,\n  ])\n\n  const expandedDepth = findExpandedDepth(expanded)\n\n  return {\n    ...instance,\n    toggleExpandedByPath,\n    expandedDepth,\n    rows: expandedRows,\n  }\n}\n\nfunction findExpandedDepth(expanded) {\n  let maxDepth = 0\n\n  expanded.forEach(key => {\n    const path = key.split('.')\n    maxDepth = Math.max(maxDepth, path.length)\n  })\n\n  return maxDepth\n}\n","export const text = (rows, id, filterValue) => {\n  rows = rows.filter(row => {\n    const rowValue = row.values[id]\n    return String(rowValue)\n      .toLowerCase()\n      .includes(String(filterValue).toLowerCase())\n  })\n  return rows\n}\n\ntext.autoRemove = val => !val\n\nexport const exactText = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue !== undefined\n      ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase()\n      : true\n  })\n}\n\nexactText.autoRemove = val => !val\n\nexport const exactTextCase = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue !== undefined\n      ? String(rowValue) === String(filterValue)\n      : true\n  })\n}\n\nexactTextCase.autoRemove = val => !val\n\nexport const includes = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return filterValue.includes(rowValue)\n  })\n}\n\nincludes.autoRemove = val => !val || !val.length\n\nexport const includesAll = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return (\n      rowValue &&\n      rowValue.length &&\n      filterValue.every(val => rowValue.includes(val))\n    )\n  })\n}\n\nincludesAll.autoRemove = val => !val || !val.length\n\nexport const exact = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue === filterValue\n  })\n}\n\nexact.autoRemove = val => typeof val === 'undefined'\n\nexport const equals = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    // eslint-disable-next-line eqeqeq\n    return rowValue == filterValue\n  })\n}\n\nequals.autoRemove = val => val == null\n\nexport const between = (rows, id, filterValue) => {\n  let [min, max] = filterValue || []\n\n  min = typeof min === 'number' ? min : -Infinity\n  max = typeof max === 'number' ? max : Infinity\n\n  if (min > max) {\n    const temp = min\n    min = max\n    max = temp\n  }\n\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue >= min && rowValue <= max\n  })\n}\n\nbetween.autoRemove = val =>\n  !val || (typeof val[0] !== 'number' && typeof val[1] !== 'number')\n","import React from 'react'\n\nimport { getFirstDefined, isFunction, safeUseLayoutEffect } from '../utils'\nimport * as filterTypes from '../filterTypes'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.filters = {}\n\naddActions('setFilter', 'setAllFilters')\n\nexport const useFilters = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseFilters.pluginName = 'useFilters'\n\nfunction useMain(instance) {\n  const {\n    debug,\n    rows,\n    flatRows,\n    flatColumns,\n    filterTypes: userFilterTypes,\n    manualFilters,\n    defaultCanFilter = false,\n    disableFilters,\n    state: { filters },\n    setState,\n    getResetFiltersDeps = false,\n  } = instance\n\n  const preFilteredRows = rows\n  const preFilteredFlatRows = flatRows\n\n  // Bypass any effects from firing when this changes\n  const isMountedRef = React.useRef()\n  safeUseLayoutEffect(() => {\n    if (isMountedRef.current) {\n      setState(\n        old => ({\n          ...old,\n          filters: {},\n        }),\n        actions.pageChange\n      )\n    }\n    isMountedRef.current = true\n  }, [setState, ...(getResetFiltersDeps ? getResetFiltersDeps(instance) : [])])\n\n  const setFilter = (id, updater) => {\n    const column = flatColumns.find(d => d.id === id)\n\n    if (!column) {\n      throw new Error(`React-Table: Could not find a column with id: ${id}`)\n    }\n\n    const filterMethod = getFilterMethod(\n      column.filter,\n      userFilterTypes || {},\n      filterTypes\n    )\n\n    return setState(old => {\n      const newFilter =\n        typeof updater === 'function' ? updater(old.filters[id]) : updater\n\n      //\n      if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {\n        const { [id]: remove, ...newFilters } = old.filters\n        return {\n          ...old,\n          filters: newFilters,\n        }\n      }\n\n      return {\n        ...old,\n        filters: {\n          ...old.filters,\n          [id]: newFilter,\n        },\n      }\n    }, actions.setFilter)\n  }\n\n  const setAllFilters = updater => {\n    return setState(old => {\n      const newFilters = typeof updater === 'function' ? updater(old) : updater\n\n      // Filter out undefined values\n      Object.keys(newFilters).forEach(id => {\n        const newFilter = newFilters[id]\n        const column = flatColumns.find(d => d.id === id)\n        const filterMethod = getFilterMethod(\n          column.filter,\n          userFilterTypes || {},\n          filterTypes\n        )\n\n        if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {\n          delete newFilters[id]\n        }\n      })\n\n      return {\n        ...old,\n        filters: newFilters,\n      }\n    }, actions.setAllFilters)\n  }\n\n  flatColumns.forEach(column => {\n    const {\n      id,\n      accessor,\n      defaultCanFilter: columnDefaultCanFilter,\n      disableFilters: columnDisableFilters,\n    } = column\n\n    // Determine if a column is filterable\n    column.canFilter = accessor\n      ? getFirstDefined(\n          columnDisableFilters === true ? false : undefined,\n          disableFilters === true ? false : undefined,\n          true\n        )\n      : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false)\n\n    // Provide the column a way of updating the filter value\n    column.setFilter = val => setFilter(column.id, val)\n\n    // Provide the current filter value to the column for\n    // convenience\n    column.filterValue = filters[id]\n  })\n\n  // TODO: Create a filter cache for incremental high speed multi-filtering\n  // This gets pretty complicated pretty fast, since you have to maintain a\n  // cache for each row group (top-level rows, and each row's recursive subrows)\n  // This would make multi-filtering a lot faster though. Too far?\n\n  const { filteredRows, filteredFlatRows } = React.useMemo(() => {\n    if (manualFilters || !Object.keys(filters).length) {\n      return {\n        filteredRows: rows,\n        filteredFlatRows: flatRows,\n      }\n    }\n\n    const filteredFlatRows = []\n\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.info('getFilteredRows')\n\n    // Filters top level and nested rows\n    const filterRows = (rows, depth = 0) => {\n      let filteredRows = rows\n\n      filteredRows = Object.entries(filters).reduce(\n        (filteredSoFar, [columnID, filterValue]) => {\n          // Find the filters column\n          const column = flatColumns.find(d => d.id === columnID)\n\n          if (!column) {\n            return filteredSoFar\n          }\n\n          if (depth === 0) {\n            column.preFilteredRows = filteredSoFar\n          }\n\n          const filterMethod = getFilterMethod(\n            column.filter,\n            userFilterTypes || {},\n            filterTypes\n          )\n\n          if (!filterMethod) {\n            console.warn(\n              `Could not find a valid 'column.filter' for column with the ID: ${column.id}.`\n            )\n            return filteredSoFar\n          }\n\n          // Pass the rows, id, filterValue and column to the filterMethod\n          // to get the filtered rows back\n          column.filteredRows = filterMethod(\n            filteredSoFar,\n            columnID,\n            filterValue,\n            column\n          )\n\n          return column.filteredRows\n        },\n        rows\n      )\n\n      // Apply the filter to any subRows\n      // We technically could do this recursively in the above loop,\n      // but that would severely hinder the API for the user, since they\n      // would be required to do that recursion in some scenarios\n      filteredRows = filteredRows.map(row => {\n        filteredFlatRows.push(row)\n        if (!row.subRows) {\n          return row\n        }\n        return {\n          ...row,\n          subRows:\n            row.subRows && row.subRows.length > 0\n              ? filterRows(row.subRows, depth + 1)\n              : row.subRows,\n        }\n      })\n\n      return filteredRows\n    }\n\n    return {\n      filteredRows: filterRows(rows),\n      filteredFlatRows,\n    }\n  }, [\n    manualFilters,\n    filters,\n    debug,\n    rows,\n    flatRows,\n    flatColumns,\n    userFilterTypes,\n  ])\n\n  React.useMemo(() => {\n    // Now that each filtered column has it's partially filtered rows,\n    // lets assign the final filtered rows to all of the other columns\n    const nonFilteredColumns = flatColumns.filter(\n      column => !Object.keys(filters).includes(column.id)\n    )\n\n    // This essentially enables faceted filter options to be built easily\n    // using every column's preFilteredRows value\n    nonFilteredColumns.forEach(column => {\n      column.preFilteredRows = filteredRows\n      column.filteredRows = filteredRows\n    })\n  }, [filteredRows, filters, flatColumns])\n\n  return {\n    ...instance,\n    setFilter,\n    setAllFilters,\n    preFilteredRows,\n    preFilteredFlatRows,\n    rows: filteredRows,\n    flatRows: filteredFlatRows,\n  }\n}\n\nfunction shouldAutoRemove(autoRemove, value) {\n  return autoRemove ? autoRemove(value) : typeof value === 'undefined'\n}\n\nfunction getFilterMethod(filter, userFilterTypes, filterTypes) {\n  return (\n    isFunction(filter) ||\n    userFilterTypes[filter] ||\n    filterTypes[filter] ||\n    filterTypes.text\n  )\n}\n","export function sum(values, rows) {\n  return values.reduce((sum, next) => sum + next, 0)\n}\n\nexport function average(values, rows) {\n  return Math.round((sum(values, rows) / values.length) * 100) / 100\n}\n\nexport function median(values) {\n  values = values.length ? values : [0]\n  let min = Math.min(...values)\n  let max = Math.max(...values)\n\n  return (min + max) / 2\n}\n\nexport function uniqueCount(values) {\n  return new Set(values).size\n}\n\nexport function count(values) {\n  return values.length\n}\n","import React from 'react'\n\nimport * as aggregations from '../aggregations'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\nimport {\n  mergeProps,\n  applyPropHooks,\n  defaultGroupByFn,\n  getFirstDefined,\n  ensurePluginOrder,\n} from '../utils'\n\ndefaultState.groupBy = []\n\naddActions('toggleGroupBy')\n\nexport const useGroupBy = hooks => {\n  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups)\n  hooks.columnsBeforeHeaderGroupsDeps.push((deps, instance) => {\n    deps.push(instance.state.groupBy)\n    return deps\n  })\n  hooks.useMain.push(useMain)\n}\n\nuseGroupBy.pluginName = 'useGroupBy'\n\nfunction columnsBeforeHeaderGroups(flatColumns, { state: { groupBy } }) {\n  // Sort grouped columns to the start of the column list\n  // before the headers are built\n\n  const groupByColumns = groupBy.map(g => flatColumns.find(col => col.id === g))\n  const nonGroupByColumns = flatColumns.filter(col => !groupBy.includes(col.id))\n\n  // If a groupByBoundary column is found, place the groupBy's after it\n  const groupByBoundaryColumnIndex =\n    flatColumns.findIndex(column => column.groupByBoundary) + 1\n\n  return [\n    ...nonGroupByColumns.slice(0, groupByBoundaryColumnIndex),\n    ...groupByColumns,\n    ...nonGroupByColumns.slice(groupByBoundaryColumnIndex),\n  ]\n}\n\nfunction useMain(instance) {\n  const {\n    debug,\n    rows,\n    flatColumns,\n    flatHeaders,\n    groupByFn = defaultGroupByFn,\n    manualGroupBy,\n    defaultCanGroupBy,\n    disableGroupBy,\n    aggregations: userAggregations = {},\n    hooks,\n    plugins,\n    state: { groupBy },\n    setState,\n  } = instance\n\n  ensurePluginOrder(plugins, [], 'useGroupBy', ['useSortBy', 'useExpanded'])\n\n  flatColumns.forEach(column => {\n    const {\n      id,\n      accessor,\n      defaultGroupBy: defaultColumnGroupBy,\n      disableGroupBy: columnDisableGroupBy,\n    } = column\n    column.isGrouped = groupBy.includes(id)\n    column.groupedIndex = groupBy.indexOf(id)\n\n    column.canGroupBy = accessor\n      ? getFirstDefined(\n          columnDisableGroupBy === true ? false : undefined,\n          disableGroupBy === true ? false : undefined,\n          true\n        )\n      : getFirstDefined(defaultColumnGroupBy, defaultCanGroupBy, false)\n\n    if (column.canGroupBy) {\n      column.toggleGroupBy = () => toggleGroupBy(column.id)\n    }\n\n    column.Aggregated = column.Aggregated || column.Cell\n  })\n\n  const toggleGroupBy = (id, toggle) => {\n    return setState(old => {\n      const resolvedToggle =\n        typeof toggle !== 'undefined' ? toggle : !groupBy.includes(id)\n      if (resolvedToggle) {\n        return {\n          ...old,\n          groupBy: [...groupBy, id],\n        }\n      }\n      return {\n        ...old,\n        groupBy: groupBy.filter(d => d !== id),\n      }\n    }, actions.toggleGroupBy)\n  }\n\n  hooks.getGroupByToggleProps = []\n\n  flatHeaders.forEach(header => {\n    const { canGroupBy } = header\n    header.getGroupByToggleProps = props => {\n      return mergeProps(\n        {\n          onClick: canGroupBy\n            ? e => {\n                e.persist()\n                header.toggleGroupBy()\n              }\n            : undefined,\n          style: {\n            cursor: canGroupBy ? 'pointer' : undefined,\n          },\n          title: 'Toggle GroupBy',\n        },\n        applyPropHooks(instance.hooks.getGroupByToggleProps, header, instance),\n        props\n      )\n    }\n  })\n\n  hooks.prepareRow.push(row => {\n    row.cells.forEach(cell => {\n      // Grouped cells are in the groupBy and the pivot cell for the row\n      cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID\n      // Repeated cells are any columns in the groupBy that are not grouped\n      cell.isRepeatedValue = !cell.isGrouped && cell.column.isGrouped\n      // Aggregated cells are not grouped, not repeated, but still have subRows\n      cell.isAggregated =\n        !cell.isGrouped && !cell.isRepeatedValue && row.canExpand\n    })\n    return row\n  })\n\n  const groupedRows = React.useMemo(() => {\n    if (manualGroupBy || !groupBy.length) {\n      return rows\n    }\n\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.info('getGroupedRows')\n    // Find the columns that can or are aggregating\n\n    // Uses each column to aggregate rows into a single value\n    const aggregateRowsToValues = (rows, isSourceRows) => {\n      const values = {}\n\n      flatColumns.forEach(column => {\n        // Don't aggregate columns that are in the groupBy\n        if (groupBy.includes(column.id)) {\n          values[column.id] = rows[0] ? rows[0].values[column.id] : null\n          return\n        }\n\n        const columnValues = rows.map(d => d.values[column.id])\n\n        let aggregator = column.aggregate\n\n        if (Array.isArray(aggregator)) {\n          if (aggregator.length !== 2) {\n            console.info({ column })\n            throw new Error(\n              `React Table: Complex aggregators must have 2 values, eg. aggregate: ['sum', 'count']. More info above...`\n            )\n          }\n          if (isSourceRows) {\n            aggregator = aggregator[1]\n          } else {\n            aggregator = aggregator[0]\n          }\n        }\n\n        let aggregateFn =\n          typeof aggregator === 'function'\n            ? aggregator\n            : userAggregations[aggregator] || aggregations[aggregator]\n\n        if (aggregateFn) {\n          values[column.id] = aggregateFn(columnValues, rows)\n        } else if (aggregator) {\n          console.info({ column })\n          throw new Error(\n            `React Table: Invalid aggregate option for column listed above`\n          )\n        } else {\n          values[column.id] = null\n        }\n      })\n      return values\n    }\n\n    // Recursively group the data\n    const groupRecursively = (rows, depth = 0, parentPath = []) => {\n      // This is the last level, just return the rows\n      if (depth >= groupBy.length) {\n        return rows\n      }\n\n      const columnID = groupBy[depth]\n\n      // Group the rows together for this level\n      let groupedRows = groupByFn(rows, columnID)\n\n      // Recurse to sub rows before aggregation\n      groupedRows = Object.entries(groupedRows).map(\n        ([groupByVal, subRows], index) => {\n          const path = [...parentPath, `${columnID}:${groupByVal}`]\n\n          subRows = groupRecursively(subRows, depth + 1, path)\n\n          const values = aggregateRowsToValues(\n            subRows,\n            depth + 1 >= groupBy.length\n          )\n\n          const row = {\n            isAggregated: true,\n            groupByID: columnID,\n            groupByVal,\n            values,\n            subRows,\n            depth,\n            index,\n            path,\n          }\n\n          return row\n        }\n      )\n\n      return groupedRows\n    }\n\n    // Assign the new data\n    return groupRecursively(rows)\n  }, [\n    manualGroupBy,\n    groupBy,\n    debug,\n    rows,\n    flatColumns,\n    userAggregations,\n    groupByFn,\n  ])\n\n  return {\n    ...instance,\n    toggleGroupBy,\n    rows: groupedRows,\n    preGroupedRows: rows,\n  }\n}\n","const reSplitAlphaNumeric = /([0-9]+)/gm\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nexport const alphanumeric = (rowA, rowB, columnID) => {\n  let a = getRowValueByColumnID(rowA, columnID)\n  let b = getRowValueByColumnID(rowB, columnID)\n  // Force to strings (or \"\" for unsupported types)\n  a = toString(a)\n  b = toString(b)\n\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  a = a.split(reSplitAlphaNumeric).filter(Boolean)\n  b = b.split(reSplitAlphaNumeric).filter(Boolean)\n\n  // While\n  while (a.length && b.length) {\n    let aa = a.shift()\n    let bb = b.shift()\n\n    const an = parseInt(aa, 10)\n    const bn = parseInt(bb, 10)\n\n    const combo = [an, bn].sort()\n\n    // Both are string\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1\n      }\n      if (bb > aa) {\n        return -1\n      }\n      continue\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1\n    }\n    if (bn > an) {\n      return -1\n    }\n  }\n\n  return a.length - b.length\n}\n\nexport function datetime(rowA, rowB, columnID) {\n  let a = getRowValueByColumnID(rowA, columnID)\n  let b = getRowValueByColumnID(rowB, columnID)\n\n  a = a.getTime()\n  b = b.getTime()\n\n  return compareBasic(a, b)\n}\n\nexport function basic(rowA, rowB, columnID) {\n  let a = getRowValueByColumnID(rowA, columnID)\n  let b = getRowValueByColumnID(rowB, columnID)\n\n  return compareBasic(a, b)\n}\n\n// Utils\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\nfunction getRowValueByColumnID(row, columnID) {\n  return row.values[columnID]\n}\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return ''\n    }\n    return String(a)\n  }\n  if (typeof a === 'string') {\n    return a\n  }\n  return ''\n}\n","import React from 'react'\n\nimport { ensurePluginOrder, defaultColumn, safeUseLayoutEffect } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\nimport * as sortTypes from '../sortTypes'\nimport {\n  mergeProps,\n  applyPropHooks,\n  getFirstDefined,\n  defaultOrderByFn,\n  isFunction,\n} from '../utils'\n\ndefaultState.sortBy = []\ndefaultColumn.sortType = 'alphanumeric'\ndefaultColumn.sortDescFirst = false\n\naddActions('sortByChange')\n\nexport const useSortBy = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseSortBy.pluginName = 'useSortBy'\n\nfunction useMain(instance) {\n  const {\n    debug,\n    rows,\n    flatColumns,\n    orderByFn = defaultOrderByFn,\n    sortTypes: userSortTypes,\n    manualSorting,\n    defaultCanSort,\n    disableSortBy,\n    disableSortRemove,\n    disableMultiRemove,\n    disableMultiSort,\n    isMultiSortEvent = e => e.shiftKey,\n    maxMultiSortColCount = Number.MAX_SAFE_INTEGER,\n    flatHeaders,\n    hooks,\n    state: { sortBy },\n    setState,\n    plugins,\n    getResetSortByDeps = false,\n  } = instance\n\n  ensurePluginOrder(plugins, ['useFilters'], 'useSortBy', [])\n  // Add custom hooks\n  hooks.getSortByToggleProps = []\n\n  // Bypass any effects from firing when this changes\n  const isMountedRef = React.useRef()\n  safeUseLayoutEffect(() => {\n    if (isMountedRef.current) {\n      setState(\n        old => ({\n          ...old,\n          sortBy: [],\n        }),\n        actions.pageChange\n      )\n    }\n    isMountedRef.current = true\n  }, [setState, ...(getResetSortByDeps ? getResetSortByDeps(instance) : [])])\n\n  // Updates sorting based on a columnID, desc flag and multi flag\n  const toggleSortBy = (columnID, desc, multi) => {\n    return setState(old => {\n      const { sortBy } = old\n\n      // Find the column for this columnID\n      const column = flatColumns.find(d => d.id === columnID)\n      const { sortDescFirst } = column\n\n      // Find any existing sortBy for this column\n      const existingSortBy = sortBy.find(d => d.id === columnID)\n      const existingIndex = sortBy.findIndex(d => d.id === columnID)\n      const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n      let newSortBy = []\n\n      // What should we do with this sort action?\n      let action\n\n      if (!disableMultiSort && multi) {\n        if (existingSortBy) {\n          action = 'toggle'\n        } else {\n          action = 'add'\n        }\n      } else {\n        // Normal mode\n        if (existingIndex !== sortBy.length - 1) {\n          action = 'replace'\n        } else if (existingSortBy) {\n          action = 'toggle'\n        } else {\n          action = 'replace'\n        }\n      }\n\n      // Handle toggle states that will remove the sortBy\n      if (\n        action === 'toggle' && // Must be toggling\n        !disableSortRemove && // If disableSortRemove, disable in general\n        !hasDescDefined && // Must not be setting desc\n        (multi ? !disableMultiRemove : true) && // If multi, don't allow if disableMultiRemove\n        ((existingSortBy && // Finally, detect if it should indeed be removed\n          existingSortBy.desc &&\n          !sortDescFirst) ||\n          (!existingSortBy.desc && sortDescFirst))\n      ) {\n        action = 'remove'\n      }\n\n      if (action === 'replace') {\n        newSortBy = [\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : sortDescFirst,\n          },\n        ]\n      } else if (action === 'add') {\n        newSortBy = [\n          ...sortBy,\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : sortDescFirst,\n          },\n        ]\n        // Take latest n columns\n        newSortBy.splice(0, newSortBy.length - maxMultiSortColCount)\n      } else if (action === 'toggle') {\n        // This flips (or sets) the\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc: hasDescDefined ? desc : !existingSortBy.desc,\n            }\n          }\n          return d\n        })\n      } else if (action === 'remove') {\n        newSortBy = sortBy.filter(d => d.id !== columnID)\n      }\n\n      return {\n        ...old,\n        sortBy: newSortBy,\n      }\n    }, actions.sortByChange)\n  }\n\n  // Add the getSortByToggleProps method to columns and headers\n  flatHeaders.forEach(column => {\n    const {\n      accessor,\n      canSort: defaultColumnCanSort,\n      disableSortBy: columnDisableSortBy,\n      id,\n    } = column\n\n    const canSort = accessor\n      ? getFirstDefined(\n          columnDisableSortBy === true ? false : undefined,\n          disableSortBy === true ? false : undefined,\n          true\n        )\n      : getFirstDefined(defaultCanSort, defaultColumnCanSort, false)\n\n    column.canSort = canSort\n\n    if (column.canSort) {\n      column.toggleSortBy = (desc, multi) =>\n        toggleSortBy(column.id, desc, multi)\n\n      column.clearSorting = () => {\n        return setState(old => {\n          const { sortBy } = old\n          const newSortBy = sortBy.filter(d => d.id !== column.id)\n          return {\n            ...old,\n            sortBy: newSortBy,\n          }\n        }, actions.sortByChange)\n      }\n    }\n\n    column.getSortByToggleProps = props => {\n      return mergeProps(\n        {\n          onClick: canSort\n            ? e => {\n                e.persist()\n                column.toggleSortBy(\n                  undefined,\n                  !instance.disableMultiSort && isMultiSortEvent(e)\n                )\n              }\n            : undefined,\n          style: {\n            cursor: canSort ? 'pointer' : undefined,\n          },\n          title: 'Toggle SortBy',\n        },\n        applyPropHooks(instance.hooks.getSortByToggleProps, column, instance),\n        props\n      )\n    }\n\n    const columnSort = sortBy.find(d => d.id === id)\n    column.isSorted = !!columnSort\n    column.sortedIndex = sortBy.findIndex(d => d.id === id)\n    column.isSortedDesc = column.isSorted ? columnSort.desc : undefined\n  })\n\n  const sortedRows = React.useMemo(() => {\n    if (manualSorting || !sortBy.length) {\n      return rows\n    }\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.time('getSortedRows')\n\n    // Filter out sortBys that correspond to non existing columns\n    const availableSortBy = sortBy.filter(sort =>\n      flatColumns.find(col => col.id === sort.id)\n    )\n\n    const sortData = rows => {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = orderByFn(\n        rows,\n        availableSortBy.map(sort => {\n          // Support custom sorting methods for each column\n          const column = flatColumns.find(d => d.id === sort.id)\n\n          if (!column) {\n            throw new Error(\n              `React-Table: Could not find a column with id: ${sort.id} while sorting`\n            )\n          }\n\n          const { sortType } = column\n\n          // Look up sortBy functions in this order:\n          // column function\n          // column string lookup on user sortType\n          // column string lookup on built-in sortType\n          // default function\n          // default string lookup on user sortType\n          // default string lookup on built-in sortType\n          const sortMethod =\n            isFunction(sortType) ||\n            (userSortTypes || {})[sortType] ||\n            sortTypes[sortType]\n\n          if (!sortMethod) {\n            throw new Error(\n              `React-Table: Could not find a valid sortType of '${sortType}' for column '${sort.id}'.`\n            )\n          }\n\n          // Return the correct sortFn.\n          // This function should always return in ascending order\n          return (a, b) => sortMethod(a, b, sort.id)\n        }),\n        // Map the directions\n        availableSortBy.map(sort => {\n          // Detect and use the sortInverted option\n          const column = flatColumns.find(d => d.id === sort.id)\n\n          if (column && column.sortInverted) {\n            return sort.desc\n          }\n\n          return !sort.desc\n        })\n      )\n\n      // If there are sub-rows, sort them\n      sortedData.forEach(row => {\n        if (!row.subRows || row.subRows.length <= 1) {\n          return\n        }\n        row.subRows = sortData(row.subRows)\n      })\n\n      return sortedData\n    }\n\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.timeEnd('getSortedRows')\n\n    return sortData(rows)\n  }, [\n    manualSorting,\n    sortBy,\n    debug,\n    rows,\n    flatColumns,\n    orderByFn,\n    userSortTypes,\n  ])\n\n  return {\n    ...instance,\n    toggleSortBy,\n    rows: sortedRows,\n    preSortedRows: rows,\n  }\n}\n","import React from 'react'\n\n//\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\nimport { ensurePluginOrder, safeUseLayoutEffect, expandRows } from '../utils'\n\ndefaultState.pageSize = 10\ndefaultState.pageIndex = 0\n\naddActions('pageChange', 'pageSizeChange')\n\nexport const usePagination = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nusePagination.pluginName = 'usePagination'\n\nconst defaultGetResetPageDeps = ({\n  rows,\n  manualPagination,\n  state: { filters, groupBy, sortBy },\n}) => [manualPagination ? null : rows, filters, groupBy, sortBy]\n\nfunction useMain(instance) {\n  const {\n    rows,\n    manualPagination,\n    getResetPageDeps = defaultGetResetPageDeps,\n    manualExpandedKey = 'expanded',\n    debug,\n    plugins,\n    pageCount: userPageCount,\n    paginateExpandedRows = true,\n    expandSubRows = true,\n    state: { pageSize, pageIndex, expanded },\n    setState,\n  } = instance\n\n  ensurePluginOrder(\n    plugins,\n    ['useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'],\n    'usePagination',\n    []\n  )\n\n  // Bypass any effects from firing when this changes\n  const isMountedRef = React.useRef()\n  safeUseLayoutEffect(() => {\n    if (isMountedRef.current) {\n      setState(\n        old => ({\n          ...old,\n          pageIndex: 0,\n        }),\n        actions.pageChange\n      )\n    }\n    isMountedRef.current = true\n  }, [setState, ...(getResetPageDeps ? getResetPageDeps(instance) : [])])\n\n  const pageCount = manualPagination\n    ? userPageCount\n    : Math.ceil(rows.length / pageSize)\n\n  const pageOptions = React.useMemo(\n    () => (pageCount > 0 ? [...new Array(pageCount)].map((d, i) => i) : []),\n    [pageCount]\n  )\n\n  const page = React.useMemo(() => {\n    let page\n\n    if (manualPagination) {\n      page = rows\n    } else {\n      if (process.env.NODE_ENV === 'development' && debug)\n        console.info('getPage')\n\n      const pageStart = pageSize * pageIndex\n      const pageEnd = pageStart + pageSize\n\n      page = rows.slice(pageStart, pageEnd)\n    }\n\n    if (paginateExpandedRows) {\n      return page\n    }\n\n    return expandRows(page, { manualExpandedKey, expanded, expandSubRows })\n  }, [\n    debug,\n    expandSubRows,\n    expanded,\n    manualExpandedKey,\n    manualPagination,\n    pageIndex,\n    pageSize,\n    paginateExpandedRows,\n    rows,\n  ])\n\n  const canPreviousPage = pageIndex > 0\n  const canNextPage = pageCount === -1 || pageIndex < pageCount - 1\n\n  const gotoPage = React.useCallback(\n    updater => {\n      if (process.env.NODE_ENV === 'development' && debug)\n        console.info('gotoPage')\n      return setState(old => {\n        const newPageIndex =\n          typeof updater === 'function' ? updater(old.pageIndex) : updater\n\n        if (newPageIndex < 0 || newPageIndex > pageCount - 1) {\n          return old\n        }\n        return {\n          ...old,\n          pageIndex: newPageIndex,\n        }\n      }, actions.pageChange)\n    },\n    [debug, pageCount, setState]\n  )\n\n  const previousPage = React.useCallback(() => {\n    return gotoPage(old => old - 1)\n  }, [gotoPage])\n\n  const nextPage = React.useCallback(() => {\n    return gotoPage(old => old + 1)\n  }, [gotoPage])\n\n  const setPageSize = React.useCallback(\n    pageSize => {\n      setState(old => {\n        const topRowIndex = old.pageSize * old.pageIndex\n        const pageIndex = Math.floor(topRowIndex / pageSize)\n        return {\n          ...old,\n          pageIndex,\n          pageSize,\n        }\n      }, actions.pageSizeChange)\n    },\n    [setState]\n  )\n\n  return {\n    ...instance,\n    pageOptions,\n    pageCount,\n    page,\n    canPreviousPage,\n    canNextPage,\n    gotoPage,\n    previousPage,\n    nextPage,\n    setPageSize,\n    pageIndex,\n    pageSize,\n  }\n}\n","import React from 'react'\n\nimport {\n  mergeProps,\n  applyPropHooks,\n  ensurePluginOrder,\n  safeUseLayoutEffect,\n} from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.selectedRowPaths = []\n\naddActions('toggleRowSelected', 'toggleRowSelectedAll')\n\nexport const useRowSelect = hooks => {\n  hooks.getToggleRowSelectedProps = []\n  hooks.getToggleAllRowsSelectedProps = []\n  hooks.useRows.push(useRows)\n  hooks.useMain.push(useMain)\n}\n\nuseRowSelect.pluginName = 'useRowSelect'\n\nfunction useRows(rows, instance) {\n  const {\n    state: { selectedRowPaths },\n  } = instance\n\n  instance.selectedFlatRows = React.useMemo(() => {\n    const selectedFlatRows = []\n    rows.forEach(row => {\n      if (row.isAggregated) {\n        const subRowPaths = row.subRows.map(row => row.path)\n        row.isSelected = subRowPaths.every(path =>\n          selectedRowPaths.includes(path.join('.'))\n        )\n      } else {\n        row.isSelected = selectedRowPaths.includes(row.path.join('.'))\n      }\n      if (row.isSelected) {\n        selectedFlatRows.push(row)\n      }\n    })\n\n    return selectedFlatRows\n  }, [rows, selectedRowPaths])\n\n  return rows\n}\n\nconst defaultGetResetSelectedRowPathsDeps = ({ rows }) => [rows]\n\nfunction useMain(instance) {\n  const {\n    hooks,\n    manualRowSelectedKey = 'isSelected',\n    plugins,\n    flatRows,\n    getResetSelectedRowPathsDeps = defaultGetResetSelectedRowPathsDeps,\n    state: { selectedRowPaths },\n    setState,\n  } = instance\n\n  ensurePluginOrder(\n    plugins,\n    ['useFilters', 'useGroupBy', 'useSortBy'],\n    'useRowSelect',\n    []\n  )\n\n  const flatRowPaths = flatRows.map(d => d.path.join('.'))\n\n  let isAllRowsSelected = !!flatRowPaths.length && !!selectedRowPaths.length\n\n  if (isAllRowsSelected) {\n    if (flatRowPaths.some(d => !selectedRowPaths.includes(d))) {\n      isAllRowsSelected = false\n    }\n  }\n\n  // Bypass any effects from firing when this changes\n  const isMountedRef = React.useRef()\n  safeUseLayoutEffect(() => {\n    if (isMountedRef.current) {\n      setState(\n        old => ({\n          ...old,\n          selectedRowPaths: [],\n        }),\n        actions.pageChange\n      )\n    }\n    isMountedRef.current = true\n  }, [\n    setState,\n    ...(getResetSelectedRowPathsDeps\n      ? getResetSelectedRowPathsDeps(instance)\n      : []),\n  ])\n\n  const toggleRowSelectedAll = set => {\n    setState(old => {\n      const selectAll = typeof set !== 'undefined' ? set : !isAllRowsSelected\n      return {\n        ...old,\n        selectedRowPaths: selectAll ? flatRowPaths : [],\n      }\n    }, actions.toggleRowSelectedAll)\n  }\n\n  const updateParentRow = (selectedRowPaths, path) => {\n    const parentPath = path.slice(0, path.length - 1)\n    const parentKey = parentPath.join('.')\n    const selected =\n      flatRowPaths.filter(rowPath => {\n        const path = rowPath\n        return (\n          path !== parentKey &&\n          path.startsWith(parentKey) &&\n          !selectedRowPaths.has(path)\n        )\n      }).length === 0\n    if (selected) {\n      selectedRowPaths.add(parentKey)\n    } else {\n      selectedRowPaths.delete(parentKey)\n    }\n    if (parentPath.length > 1) updateParentRow(selectedRowPaths, parentPath)\n  }\n\n  const toggleRowSelected = (path, set) => {\n    const key = path.join('.')\n    const childRowPrefixKey = [key, '.'].join('')\n\n    return setState(old => {\n      // Join the paths of deep rows\n      // to make a key, then manage all of the keys\n      // in a flat object\n      const exists = old.selectedRowPaths.includes(key)\n      const shouldExist = typeof set !== 'undefined' ? set : !exists\n      let newSelectedRows = new Set(old.selectedRowPaths)\n\n      if (!exists && shouldExist) {\n        flatRowPaths.forEach(rowPath => {\n          if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {\n            newSelectedRows.add(rowPath)\n          }\n        })\n      } else if (exists && !shouldExist) {\n        flatRowPaths.forEach(rowPath => {\n          if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {\n            newSelectedRows.delete(rowPath)\n          }\n        })\n      } else {\n        return old\n      }\n\n      // If the row is a subRow update\n      // its parent row to reflect changes\n      if (path.length > 1) updateParentRow(newSelectedRows, path)\n\n      return {\n        ...old,\n        selectedRowPaths: [...newSelectedRows.values()],\n      }\n    }, actions.toggleRowSelected)\n  }\n\n  const getToggleAllRowsSelectedProps = props => {\n    return mergeProps(\n      {\n        onChange: e => {\n          toggleRowSelectedAll(e.target.checked)\n        },\n        style: {\n          cursor: 'pointer',\n        },\n        checked: isAllRowsSelected,\n        title: 'Toggle All Rows Selected',\n      },\n      applyPropHooks(instance.hooks.getToggleAllRowsSelectedProps, instance),\n      props\n    )\n  }\n\n  hooks.prepareRow.push(row => {\n    // Aggregate rows have entirely different select logic\n    if (row.isAggregated) {\n      const subRowPaths = row.subRows.map(row => row.path)\n      row.toggleRowSelected = set => {\n        set = typeof set !== 'undefined' ? set : !row.isSelected\n        subRowPaths.forEach(path => {\n          toggleRowSelected(path, set)\n        })\n      }\n      row.getToggleRowSelectedProps = props => {\n        let checked = false\n\n        if (row.original && row.original[manualRowSelectedKey]) {\n          checked = true\n        } else {\n          checked = row.isSelected\n        }\n\n        return mergeProps(\n          {\n            onChange: e => {\n              row.toggleRowSelected(e.target.checked)\n            },\n            style: {\n              cursor: 'pointer',\n            },\n            checked,\n            title: 'Toggle Row Selected',\n          },\n          applyPropHooks(\n            instance.hooks.getToggleRowSelectedProps,\n            row,\n            instance\n          ),\n          props\n        )\n      }\n    } else {\n      row.toggleRowSelected = set => toggleRowSelected(row.path, set)\n      row.getToggleRowSelectedProps = props => {\n        let checked = false\n\n        if (row.original && row.original[manualRowSelectedKey]) {\n          checked = true\n        } else {\n          checked = row.isSelected\n        }\n\n        return mergeProps(\n          {\n            onChange: e => {\n              row.toggleRowSelected(e.target.checked)\n            },\n            style: {\n              cursor: 'pointer',\n            },\n            checked,\n            title: 'Toggle Row Selected',\n          },\n          applyPropHooks(\n            instance.hooks.getToggleRowSelectedProps,\n            row,\n            instance\n          ),\n          props\n        )\n      }\n    }\n\n    return row\n  })\n\n  return {\n    ...instance,\n    toggleRowSelected,\n    toggleRowSelectedAll,\n    getToggleAllRowsSelectedProps,\n    isAllRowsSelected,\n  }\n}\n","import React from 'react'\n\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.rowState = {}\n\naddActions('setRowState', 'setCellState')\n\nexport const useRowState = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseRowState.pluginName = 'useRowState'\n\nfunction useMain(instance) {\n  const {\n    hooks,\n    rows,\n    initialRowStateAccessor,\n    state: { rowState },\n    setState,\n  } = instance\n\n  const setRowState = React.useCallback(\n    (path, updater, action = actions.setRowState) => {\n      const pathKey = path.join('.')\n      return setState(old => {\n        return {\n          ...old,\n          rowState: {\n            ...old.rowState,\n            [pathKey]:\n              typeof updater === 'function'\n                ? updater(old.rowState[pathKey])\n                : updater,\n          },\n        }\n      }, action)\n    },\n    [setState]\n  )\n\n  const setCellState = React.useCallback(\n    (rowPath, columnID, updater) => {\n      return setRowState(\n        rowPath,\n        old => {\n          return {\n            ...old,\n            cellState: {\n              ...old.cellState,\n              [columnID]:\n                typeof updater === 'function'\n                  ? updater(old.cellState[columnID])\n                  : updater,\n            },\n          }\n        },\n        actions.setCellState\n      )\n    },\n    [setRowState]\n  )\n\n  const rowsMountedRef = React.useRef()\n\n  // When data changes, reset row and cell state\n  React.useEffect(() => {\n    if (rowsMountedRef.current) {\n      setState(old => {\n        return {\n          ...old,\n          rowState: {},\n        }\n      }, actions.setRowState)\n    }\n\n    rowsMountedRef.current = true\n  }, [rows, setState])\n\n  hooks.prepareRow.push(row => {\n    const pathKey = row.path.join('.')\n\n    if (row.original) {\n      row.state =\n        (typeof rowState[pathKey] !== 'undefined'\n          ? rowState[pathKey]\n          : initialRowStateAccessor && initialRowStateAccessor(row)) || {}\n\n      row.setState = updater => {\n        return setRowState(row.path, updater)\n      }\n\n      row.cells.forEach(cell => {\n        cell.state = row.state.cellState || {}\n\n        cell.setState = updater => {\n          return setCellState(row.path, cell.column.id, updater)\n        }\n      })\n    }\n\n    return row\n  })\n\n  return {\n    ...instance,\n    setRowState,\n    setCellState,\n  }\n}\n","import React from 'react'\n\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.columnOrder = []\n\naddActions('setColumnOrder')\n\nexport const useColumnOrder = hooks => {\n  hooks.columnsBeforeHeaderGroupsDeps.push((deps, instance) => {\n    return [...deps, instance.state.columnOrder]\n  })\n  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups)\n  hooks.useMain.push(useMain)\n}\n\nuseColumnOrder.pluginName = 'useColumnOrder'\n\nfunction columnsBeforeHeaderGroups(columns, instance) {\n  const {\n    state: { columnOrder },\n  } = instance\n\n  // If there is no order, return the normal columns\n  if (!columnOrder || !columnOrder.length) {\n    return columns\n  }\n\n  const columnOrderCopy = [...columnOrder]\n\n  // If there is an order, make a copy of the columns\n  const columnsCopy = [...columns]\n\n  // And make a new ordered array of the columns\n  const columnsInOrder = []\n\n  // Loop over the columns and place them in order into the new array\n  while (columnsCopy.length && columnOrderCopy.length) {\n    const targetColumnID = columnOrderCopy.shift()\n    const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnID)\n    if (foundIndex > -1) {\n      columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0])\n    }\n  }\n\n  // If there are any columns left, add them to the end\n  return [...columnsInOrder, ...columnsCopy]\n}\n\nfunction useMain(instance) {\n  const { setState } = instance\n\n  const setColumnOrder = React.useCallback(\n    updater => {\n      return setState(old => {\n        return {\n          ...old,\n          columnOrder:\n            typeof updater === 'function' ? updater(old.columnOrder) : updater,\n        }\n      }, actions.setColumnOrder)\n    },\n    [setState]\n  )\n\n  return {\n    ...instance,\n    setColumnOrder,\n  }\n}\n","//\n\nimport { defaultState } from '../hooks/useTable'\nimport { defaultColumn, getFirstDefined } from '../utils'\nimport { mergeProps, applyPropHooks } from '../utils'\n\ndefaultState.columnResizing = {\n  columnWidths: {},\n}\n\ndefaultColumn.canResize = true\n\nexport const useResizeColumns = hooks => {\n  hooks.useBeforeDimensions.push(useBeforeDimensions)\n}\n\nuseResizeColumns.pluginName = 'useResizeColumns'\n\nconst useBeforeDimensions = instance => {\n  instance.hooks.getResizerProps = []\n\n  const {\n    flatHeaders,\n    disableResizing,\n    hooks: { getHeaderProps },\n    state: { columnResizing },\n    setState,\n  } = instance\n\n  getHeaderProps.push(() => {\n    return {\n      style: {\n        position: 'relative',\n      },\n    }\n  })\n\n  const onMouseDown = (e, header) => {\n    const headersToResize = getLeafHeaders(header)\n    const startWidths = headersToResize.map(header => header.totalWidth)\n    const startX = e.clientX\n\n    const onMouseMove = e => {\n      const currentX = e.clientX\n      const deltaX = currentX - startX\n\n      const percentageDeltaX = deltaX / headersToResize.length\n\n      const newColumnWidths = {}\n      headersToResize.forEach((header, index) => {\n        newColumnWidths[header.id] = Math.max(\n          startWidths[index] + percentageDeltaX,\n          0\n        )\n      })\n\n      setState(old => ({\n        ...old,\n        columnResizing: {\n          ...old.columnResizing,\n          columnWidths: {\n            ...old.columnResizing.columnWidths,\n            ...newColumnWidths,\n          },\n        },\n      }))\n    }\n\n    const onMouseUp = e => {\n      document.removeEventListener('mousemove', onMouseMove)\n      document.removeEventListener('mouseup', onMouseUp)\n\n      setState(old => ({\n        ...old,\n        columnResizing: {\n          ...old.columnResizing,\n          startX: null,\n          isResizingColumn: null,\n        },\n      }))\n    }\n\n    document.addEventListener('mousemove', onMouseMove)\n    document.addEventListener('mouseup', onMouseUp)\n\n    setState(old => ({\n      ...old,\n      columnResizing: {\n        ...old.columnResizing,\n        startX,\n        isResizingColumn: header.id,\n      },\n    }))\n  }\n\n  flatHeaders.forEach(header => {\n    const canResize = getFirstDefined(\n      header.disableResizing === true ? false : undefined,\n      disableResizing === true ? false : undefined,\n      true\n    )\n\n    header.canResize = canResize\n    header.width = columnResizing.columnWidths[header.id] || header.width\n    header.isResizing = columnResizing.isResizingColumn === header.id\n\n    if (canResize) {\n      header.getResizerProps = userProps => {\n        return mergeProps(\n          {\n            onMouseDown: e => e.persist() || onMouseDown(e, header),\n            style: {\n              cursor: 'ew-resize',\n            },\n            draggable: false,\n          },\n          applyPropHooks(instance.hooks.getResizerProps, header, instance),\n          userProps\n        )\n      }\n    }\n  })\n\n  return instance\n}\n\nfunction getLeafHeaders(header) {\n  const leafHeaders = []\n  const recurseHeader = header => {\n    if (header.columns && header.columns.length) {\n      header.columns.map(recurseHeader)\n    }\n    leafHeaders.push(header)\n  }\n  recurseHeader(header)\n  return leafHeaders\n}\n","export const useAbsoluteLayout = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseAbsoluteLayout.pluginName = 'useAbsoluteLayout'\n\nconst useMain = instance => {\n  const {\n    totalColumnsWidth,\n    hooks: {\n      getRowProps,\n      getTableBodyProps,\n      getHeaderGroupProps,\n      getHeaderProps,\n      getCellProps,\n    },\n  } = instance\n\n  const rowStyles = {\n    style: {\n      position: 'relative',\n      width: `${totalColumnsWidth}px`,\n    },\n  }\n\n  getTableBodyProps.push(() => rowStyles)\n  getRowProps.push(() => rowStyles)\n  getHeaderGroupProps.push(() => rowStyles)\n\n  // Calculating column/cells widths\n  const cellStyles = {\n    position: 'absolute',\n    top: 0,\n  }\n\n  getHeaderProps.push(header => {\n    return {\n      style: {\n        ...cellStyles,\n        left: `${header.totalLeft}px`,\n        width: `${header.totalWidth}px`,\n      },\n    }\n  })\n\n  getCellProps.push(cell => {\n    return {\n      style: {\n        ...cellStyles,\n        left: `${cell.column.totalLeft}px`,\n        width: `${cell.column.totalWidth}px`,\n      },\n    }\n  })\n\n  return instance\n}\n","export const useBlockLayout = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseBlockLayout.pluginName = 'useBlockLayout'\n\nconst useMain = instance => {\n  const {\n    totalColumnsWidth,\n    hooks: { getRowProps, getHeaderGroupProps, getHeaderProps, getCellProps },\n  } = instance\n\n  const rowStyles = {\n    style: {\n      display: 'flex',\n      width: `${totalColumnsWidth}px`,\n    },\n  }\n\n  getRowProps.push(() => rowStyles)\n  getHeaderGroupProps.push(() => rowStyles)\n\n  const cellStyles = {\n    display: 'inline-block',\n    boxSizing: 'border-box',\n  }\n\n  getHeaderProps.push(header => {\n    return {\n      style: {\n        ...cellStyles,\n        width: `${header.totalWidth}px`,\n      },\n    }\n  })\n\n  getCellProps.push(cell => {\n    return {\n      style: {\n        ...cellStyles,\n        width: `${cell.column.totalWidth}px`,\n      },\n    }\n  })\n\n  return instance\n}\n"]},"metadata":{},"sourceType":"module"}